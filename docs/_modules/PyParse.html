<!doctype html>
<html class="no-js" lang="en">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><link rel="index" title="Index" href="../genindex.html" /><link rel="search" title="Search" href="../search.html" />

    <!-- Generated with Sphinx 5.0.2 and Furo 2022.12.07 -->
        <title>PyParse - PyParse 1.1.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/furo.css?digest=91d0f0d1c444bdcb17a68e833c7a53903343c195" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/furo-extensions.css?digest=30d1aed668e5c3a91c3e3bf6a60b675221979f0e" />
    
    


<style>
  body {
    --color-code-background: #f8f8f8;
  --color-code-foreground: black;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-half" viewBox="0 0 24 24">
    <title>Auto light/dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-shadow">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
      <circle cx="12" cy="12" r="9" />
      <path d="M13 12h5" />
      <path d="M13 15h4" />
      <path d="M13 18h1" />
      <path d="M13 9h4" />
      <path d="M13 6h1" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="../index.html"><div class="brand">PyParse 1.1.0 documentation</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon no-toc" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand" href="../index.html">
  
  
  <span class="sidebar-brand-text">PyParse 1.1.0 documentation</span>
  
</a><form class="sidebar-search-container" method="get" action="../search.html" role="search">
  <input class="sidebar-search" placeholder="Search" name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../installation.html">Installation and Run</a></li>
<li class="toctree-l1"><a class="reference internal" href="../output_desc.html">PyParse Outputs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../example.html">Using the Example Dataset</a></li>
<li class="toctree-l1"><a class="reference internal" href="../freq_imp_det.html">Automatic Impurity Detection and Reporting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../filter_rt.html">Filtering by Retention Time</a></li>
<li class="toctree-l1"><a class="reference internal" href="../faq.html">Frequently Asked Questions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../add_param.html">Additional Parameters</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pyparse_det.html">PyParse Function Detail</a></li>
<li class="toctree-l1"><a class="reference internal" href="../getwaters_det.html">Acquire Data from Waterâ€™s .rpt File</a></li>
<li class="toctree-l1"><a class="reference internal" href="../getshimadzu_det.html">Acquire Data from Shimadzu .daml Files</a></li>
</ul>

</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          <div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon no-toc" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main">
          <h1>Source code for PyParse</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">Copyright 2023 GlaxoSmithKline Research &amp; Development Limited</span>

<span class="sd">Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="sd">you may not use this file except in compliance with the License.</span>
<span class="sd">You may obtain a copy of the License at</span>

<span class="sd">    http://www.apache.org/licenses/LICENSE-2.0</span>

<span class="sd">Unless required by applicable law or agreed to in writing, software</span>
<span class="sd">distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="sd">WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="sd">See the License for the specific language governing permissions and</span>
<span class="sd">limitations under the License.</span>

<span class="sd">Authors: Joe Mason, Francesco Rianjongdee, Harry Wilders, David Fallon</span>
<span class="sd">&quot;&quot;&quot;</span>


<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">os</span> <span class="kn">import</span> <span class="n">path</span>

<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">argparse</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">matplotlib.lines</span> <span class="kn">import</span> <span class="n">Line2D</span>
<span class="kn">import</span> <span class="nn">seaborn</span> <span class="k">as</span> <span class="nn">sns</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">from</span> <span class="nn">statistics</span> <span class="kn">import</span> <span class="n">mean</span>
<span class="kn">from</span> <span class="nn">rdkit</span> <span class="kn">import</span> <span class="n">Chem</span>
<span class="kn">from</span> <span class="nn">rdkit.Chem</span> <span class="kn">import</span> <span class="n">AllChem</span>
<span class="kn">from</span> <span class="nn">rdkit.Chem</span> <span class="kn">import</span> <span class="n">Descriptors</span>
<span class="kn">from</span> <span class="nn">rdkit.Chem</span> <span class="kn">import</span> <span class="n">Draw</span>
<span class="kn">import</span> <span class="nn">zipfile</span>
<span class="kn">from</span> <span class="nn">jinja2</span> <span class="kn">import</span> <span class="n">Environment</span><span class="p">,</span> <span class="n">PackageLoader</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.cm</span> <span class="k">as</span> <span class="nn">cm</span>
<span class="kn">import</span> <span class="nn">glob</span>

<span class="c1">#Import local scripts</span>
<span class="kn">import</span> <span class="nn">getShimadzuData</span>
<span class="kn">import</span> <span class="nn">getWatersData</span>



<div class="viewcode-block" id="importStructures"><a class="viewcode-back" href="../pyparse_det.html#PyParse.importStructures">[docs]</a><span class="k">def</span> <span class="nf">importStructures</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">save_dir</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    From a given CSV, with defined header names, and one row per well, </span>
<span class="sd">    deconvolute the information to give a dataframe of one compound </span>
<span class="sd">    per row, indexed by canonical SMILES. The well must be specified </span>
<span class="sd">    using a capital letter from A-Z to describe the row, and a positive integer </span>
<span class="sd">    to describve the column. Column numbers should be written as 1, 2, etc </span>
<span class="sd">    as opposed to 01, 02, etc.  </span>

<span class="sd">    :param filename: file name and directory as a string</span>
<span class="sd">    :return: List comprising [Pandas dataframe, name of internal STD, list of names of the starting materials, </span>
<span class="sd">                list of names of the products, list of names of the byproducts]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="c1">#read csv file into dataframe</span>
    <span class="c1">#replace empty cells with an empty string</span>
    <span class="c1">#convert all column names to lower case and remove whitespace</span>
    <span class="n">inputCSV</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
    <span class="n">inputCSV</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">inputCSV</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="n">inputCSV</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>

    <span class="n">compounds</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">internalSTD</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
    <span class="n">SMs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">products</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">by_products</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">global</span> <span class="n">product_count</span><span class="p">,</span> <span class="n">SM_count</span>
    <span class="n">product_count</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">SM_count</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1">#Fn to convert a well name like B5 to machine format (11)</span>
    <span class="k">def</span> <span class="nf">convertWellToNum</span><span class="p">(</span><span class="n">well</span><span class="p">):</span>
        <span class="n">row</span> <span class="o">=</span> <span class="n">well</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">column</span> <span class="o">=</span> <span class="n">well</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="c1">#if the format of the row/column conforms to expectations</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">column</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">int</span><span class="p">((</span><span class="nb">ord</span><span class="p">(</span><span class="n">row</span><span class="p">)</span> <span class="o">-</span> <span class="mi">65</span><span class="p">)</span> <span class="o">*</span> <span class="n">options</span><span class="o">.</span><span class="n">plate_col_no</span> <span class="o">+</span> <span class="nb">int</span><span class="p">(</span><span class="n">column</span><span class="p">))</span>
        <span class="c1">#Plates with more than 26 rows are unsupported at present. </span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;The well specified implies an unsupported plate.&quot;</span><span class="p">)</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">save_dir</span><span class="si">}</span><span class="s1">html_output.html&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;The well specified implies an unsupported plate.&quot;</span><span class="p">)</span>
                <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

    <span class="c1">#fn to import process each compound into the right format</span>
    <span class="k">def</span> <span class="nf">addCompound</span><span class="p">(</span><span class="n">column</span><span class="p">,</span> <span class="n">row</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">column</span> <span class="ow">in</span> <span class="n">row</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">row</span><span class="p">[</span><span class="n">column</span><span class="p">]</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
                <span class="n">g_smiles</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="n">column</span><span class="p">]</span>
                
                <span class="c1">#generate a canonical smiles for use as an index</span>
                <span class="n">mol</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="n">g_smiles</span><span class="o">.</span><span class="n">strip</span><span class="p">())</span>
                <span class="n">index</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolToSmiles</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
                
                <span class="c1">#Convert well ID to an integer</span>
                <span class="n">well</span> <span class="o">=</span> <span class="n">convertWellToNum</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;well&quot;</span><span class="p">])</span>
                
                <span class="k">if</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">compounds</span><span class="p">:</span>
                    <span class="n">compounds</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="s2">&quot;locations&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">well</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">compounds</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;locations&quot;</span><span class="p">:</span> <span class="p">[</span><span class="n">well</span><span class="p">]}</span>
                    <span class="n">compounds</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="s2">&quot;g_smiles&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">g_smiles</span>
                    
                    <span class="c1">#store the common name given by the user</span>
                    <span class="k">if</span> <span class="n">column</span> <span class="o">==</span> <span class="s2">&quot;desired product smiles&quot;</span><span class="p">:</span>
                        <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
                        <span class="k">if</span> <span class="s2">&quot;desired product name&quot;</span> <span class="ow">in</span> <span class="n">row</span> <span class="ow">and</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;desired product name&quot;</span><span class="p">]</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
                            <span class="n">name</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;desired product name&quot;</span><span class="p">]</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">global</span> <span class="n">product_count</span>
                            <span class="n">product_count</span> <span class="o">=</span> <span class="n">product_count</span> <span class="o">+</span> <span class="mi">1</span>
                            <span class="n">name</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;Product</span><span class="si">{</span><span class="n">product_count</span><span class="si">}</span><span class="s1">&#39;</span>
                        <span class="n">compounds</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="s2">&quot;name&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">name</span>

                        <span class="k">if</span> <span class="s2">&quot;desired product rt&quot;</span> <span class="ow">in</span> <span class="n">row</span> <span class="ow">and</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;desired product rt&quot;</span><span class="p">]</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
                            <span class="n">compounds</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="s2">&quot;rt&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;desired product rt&quot;</span><span class="p">])</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">compounds</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="s2">&quot;rt&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                        
                        <span class="n">compounds</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="s2">&quot;type&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;Product&quot;</span>
                        <span class="k">return</span> <span class="n">name</span>

                    <span class="k">elif</span> <span class="n">column</span> <span class="o">==</span> <span class="s2">&quot;internalstd smiles&quot;</span><span class="p">:</span>
                        <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
                        <span class="k">if</span> <span class="s2">&quot;internalstd name&quot;</span> <span class="ow">in</span> <span class="n">row</span> <span class="ow">and</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;internalstd name&quot;</span><span class="p">]</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
                            <span class="n">name</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;internalstd name&quot;</span><span class="p">]</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;InternalSTD&#39;</span>

                        <span class="n">compounds</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="s2">&quot;name&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">name</span>

                        <span class="k">if</span> <span class="s2">&quot;internalstd rt&quot;</span> <span class="ow">in</span> <span class="n">row</span> <span class="ow">and</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;internalstd rt&quot;</span><span class="p">]</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
                            <span class="n">compounds</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="s2">&quot;rt&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;internalstd rt&quot;</span><span class="p">])</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">compounds</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="s2">&quot;rt&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                        
                        <span class="n">compounds</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="s2">&quot;type&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;InternalSTD&quot;</span>
                        <span class="k">return</span> <span class="n">name</span>
                        
                    <span class="k">elif</span> <span class="n">column</span> <span class="o">==</span> <span class="s2">&quot;limiting reactant smiles&quot;</span><span class="p">:</span>
                        <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
                        <span class="k">if</span> <span class="s2">&quot;limiting reactant name&quot;</span> <span class="ow">in</span> <span class="n">row</span> <span class="ow">and</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;limiting reactant name&quot;</span><span class="p">]</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
                            <span class="n">name</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;limiting reactant name&quot;</span><span class="p">]</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">global</span> <span class="n">SM_count</span>
                            <span class="n">SM_count</span> <span class="o">=</span> <span class="n">SM_count</span> <span class="o">+</span> <span class="mi">1</span>
                            <span class="n">name</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;Reactant</span><span class="si">{</span><span class="n">SM_count</span><span class="si">}</span><span class="s1">&#39;</span>

                        <span class="n">compounds</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="s2">&quot;name&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">name</span>

                        <span class="k">if</span> <span class="s2">&quot;limiting reactant rt&quot;</span> <span class="ow">in</span> <span class="n">row</span> <span class="ow">and</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;limiting reactant rt&quot;</span><span class="p">]</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
                            <span class="n">compounds</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="s2">&quot;rt&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;limiting reactant rt&quot;</span><span class="p">])</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">compounds</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="s2">&quot;rt&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                        
                        <span class="n">compounds</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="s2">&quot;type&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;Limiting Reagent&quot;</span>
                        <span class="k">return</span> <span class="n">name</span>

                    <span class="c1">#use regex to find the byproduct columns (as multiple</span>
                    <span class="c1">#byproducts are permitted and each requires a separate column</span>
                    <span class="c1">#in the platemap.) </span>
                    <span class="k">elif</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s2">&quot;^byproduct.*smiles$&quot;</span><span class="p">,</span> <span class="n">column</span><span class="p">):</span>
                        <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
                        <span class="n">byprod_num</span> <span class="o">=</span> <span class="n">column</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;byproduct&quot;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
                        <span class="k">if</span> <span class="sa">f</span><span class="s1">&#39;byproduct</span><span class="si">{</span><span class="n">byprod_num</span><span class="si">}</span><span class="s1"> name&#39;</span> <span class="ow">in</span> <span class="n">row</span> <span class="ow">and</span> <span class="n">row</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;byproduct</span><span class="si">{</span><span class="n">byprod_num</span><span class="si">}</span><span class="s1"> name&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
                            <span class="n">name</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;byproduct</span><span class="si">{</span><span class="n">byprod_num</span><span class="si">}</span><span class="s1"> name&#39;</span><span class="p">]</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">name</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;Byproduct</span><span class="si">{</span><span class="n">byprod_num</span><span class="si">}</span><span class="s1">&#39;</span>

                        <span class="n">compounds</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="s2">&quot;name&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">name</span>

                        <span class="k">if</span> <span class="sa">f</span><span class="s1">&#39;byproduct</span><span class="si">{</span><span class="n">byprod_num</span><span class="si">}</span><span class="s1"> rt&#39;</span> <span class="ow">in</span> <span class="n">row</span> <span class="ow">and</span> <span class="n">row</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;byproduct</span><span class="si">{</span><span class="n">byprod_num</span><span class="si">}</span><span class="s1"> rt&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
                            <span class="n">compounds</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="s2">&quot;rt&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;byproduct</span><span class="si">{</span><span class="n">byprod_num</span><span class="si">}</span><span class="s1"> rt&#39;</span><span class="p">])</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">compounds</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="s2">&quot;rt&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

                        <span class="n">compounds</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="s2">&quot;type&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;Byproduct&quot;</span>
                        <span class="k">return</span> <span class="n">name</span>
        
        <span class="c1">#Returns zero if the column isn&#39;t found in that row,</span>
        <span class="c1">#or if the compound has already been added from a previous well. </span>
        <span class="k">return</span> <span class="mi">0</span>

                
    <span class="c1">#For each row (well), look to specific columns for the product, limiting reactant, etc</span>
    <span class="c1">#Store the wells that were in the input csv for future use</span>
  
    <span class="n">columns</span> <span class="o">=</span> <span class="n">inputCSV</span><span class="o">.</span><span class="n">columns</span>         
    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">inputCSV</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
        <span class="c1">#Store the returned canonical SMILES for future use</span>
        <span class="n">new_prod</span> <span class="o">=</span> <span class="n">addCompound</span><span class="p">(</span><span class="s2">&quot;desired product smiles&quot;</span><span class="p">,</span> <span class="n">row</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">new_prod</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">products</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_prod</span><span class="p">)</span>

        <span class="n">byproduct_cols</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">columns</span> <span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s2">&quot;^byproduct.*smiles$&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">byproduct_cols</span><span class="p">:</span>
            <span class="n">new_byprod</span> <span class="o">=</span> <span class="n">addCompound</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">row</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">new_byprod</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">by_products</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_byprod</span><span class="p">)</span>
        
        <span class="n">new_reactant</span> <span class="o">=</span> <span class="n">addCompound</span><span class="p">(</span><span class="s2">&quot;limiting reactant smiles&quot;</span><span class="p">,</span> <span class="n">row</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">new_reactant</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">SMs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_reactant</span><span class="p">)</span>

        <span class="n">new_standard</span> <span class="o">=</span> <span class="n">addCompound</span><span class="p">(</span><span class="s2">&quot;internalstd smiles&quot;</span><span class="p">,</span> <span class="n">row</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">new_standard</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">internalSTD</span> <span class="o">=</span> <span class="n">new_standard</span>
 
    <span class="c1">#Convert dictionary to Pandas dataframe</span>
    <span class="n">compoundDF</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">compounds</span><span class="p">,</span> <span class="n">orient</span><span class="o">=</span><span class="s2">&quot;index&quot;</span><span class="p">)</span>
    
    <span class="c1">#Location to store the isotopic mass of the compounds</span>
    <span class="n">mass1</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">mass2</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">mass3</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">options</span><span class="o">.</span><span class="n">calc_boc</span> <span class="o">==</span> <span class="s2">&quot;True&quot;</span><span class="p">:</span>

        <span class="c1">#Use RDkit to find the isotopic mass of each compound</span>
        <span class="c1">#as well as likely other masses, e.g. boc deprotection and</span>
        <span class="c1">#halide isotopes. </span>
        <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">compoundDF</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
            <span class="n">mol</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
            <span class="n">mw1</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">Descriptors</span><span class="o">.</span><span class="n">ExactMolWt</span><span class="p">(</span><span class="n">mol</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span>
            <span class="c1">#Add the parent mass to the list</span>
            <span class="n">mass1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mw1</span><span class="p">)</span>
            <span class="c1">#Set default values for mw2 and mw3</span>
            <span class="n">mw2</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">mw3</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1">#Use rdkit to perform boc degradation</span>
                <span class="n">rxn1</span> <span class="o">=</span> <span class="n">AllChem</span><span class="o">.</span><span class="n">ReactionFromSmarts</span><span class="p">(</span><span class="s2">&quot;[NX3,n:1][C:2](=[O:3])[O:4][C]([CH3])([CH3])[CH3]&gt;&gt;[*:1][C:2](=[O:3])[O:4]&quot;</span><span class="p">)</span>
                <span class="n">new_mol1</span> <span class="o">=</span> <span class="n">rxn1</span><span class="o">.</span><span class="n">RunReactants</span><span class="p">((</span><span class="n">mol</span><span class="p">,</span> <span class="p">))[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="c1">#Sanitise the molecule to make sure that a sensible molecule was produced. </span>
                <span class="n">Chem</span><span class="o">.</span><span class="n">SanitizeMol</span><span class="p">(</span><span class="n">new_mol1</span><span class="p">)</span>
                <span class="n">mw2</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">Descriptors</span><span class="o">.</span><span class="n">ExactMolWt</span><span class="p">(</span><span class="n">new_mol1</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span>
                
                <span class="c1">#Use rdkit again to get to fully deprotected molecule</span>
                <span class="n">rxn2</span> <span class="o">=</span> <span class="n">AllChem</span><span class="o">.</span><span class="n">ReactionFromSmarts</span><span class="p">(</span><span class="s2">&quot;[NX3,n:1][C](=[O])[O][C]([CH3])([CH3])[CH3]&gt;&gt;[*:1][H]&quot;</span><span class="p">)</span>
                <span class="n">new_mol2</span> <span class="o">=</span> <span class="n">rxn2</span><span class="o">.</span><span class="n">RunReactants</span><span class="p">((</span><span class="n">mol</span><span class="p">,</span> <span class="p">))[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">Chem</span><span class="o">.</span><span class="n">SanitizeMol</span><span class="p">(</span><span class="n">new_mol2</span><span class="p">)</span>
                <span class="n">mw3</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">Descriptors</span><span class="o">.</span><span class="n">ExactMolWt</span><span class="p">(</span><span class="n">new_mol2</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span>
                
                <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;A Boc group was found and disconnected for </span><span class="si">{</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span><span class="si">}</span><span class="s1">.&#39;</span><span class="p">)</span>
                
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                
                <span class="c1">#If the boc degradation failed, either because a boc group was</span>
                <span class="c1">#not found on this molecule or for other reasons, check for </span>
                <span class="c1">#halide isotope patterns. </span>
                <span class="k">if</span> <span class="s2">&quot;Cl&quot;</span> <span class="ow">in</span> <span class="n">index</span> <span class="ow">or</span> <span class="s2">&quot;Br&quot;</span> <span class="ow">in</span> <span class="n">index</span><span class="p">:</span>
                    <span class="n">mw2</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">mw1</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        
            <span class="c1">#Append new masses to list </span>
            <span class="n">mass2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mw2</span><span class="p">)</span>
            <span class="n">mass3</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mw3</span><span class="p">)</span>
        
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">compoundDF</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
            <span class="n">mol</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
            <span class="n">mw1</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">Descriptors</span><span class="o">.</span><span class="n">ExactMolWt</span><span class="p">(</span><span class="n">mol</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">mass1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mw1</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="s2">&quot;Cl&quot;</span> <span class="ow">in</span> <span class="n">index</span> <span class="ow">or</span> <span class="s2">&quot;Br&quot;</span> <span class="ow">in</span> <span class="n">index</span><span class="p">:</span>
                <span class="n">mass2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">mw1</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
                <span class="n">mass3</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">mass2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">mass3</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

    <span class="c1">#Append the mass data to the dataframe</span>
    <span class="n">compoundDF</span><span class="p">[</span><span class="s2">&quot;mass1&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mass1</span>
    <span class="n">compoundDF</span><span class="p">[</span><span class="s2">&quot;mass2&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mass2</span>
    <span class="n">compoundDF</span><span class="p">[</span><span class="s2">&quot;mass3&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mass3</span>
    
    <span class="k">return</span> <span class="p">[</span><span class="n">compoundDF</span><span class="p">,</span> <span class="n">internalSTD</span><span class="p">,</span> <span class="n">SMs</span><span class="p">,</span> <span class="n">products</span><span class="p">,</span> <span class="n">by_products</span><span class="p">]</span></div>
    

<div class="viewcode-block" id="getUserReadableWell"><a class="viewcode-back" href="../pyparse_det.html#PyParse.getUserReadableWell">[docs]</a><span class="k">def</span> <span class="nf">getUserReadableWell</span><span class="p">(</span><span class="n">wellno</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Converts the well as a number into a user-friendly string,</span>
<span class="sd">    e.g. well 11 becomes &quot;B5&quot; for a 4*6 well plate</span>

<span class="sd">    :param wellno: An integer representing a specific well on the plate</span>
<span class="sd">    </span>
<span class="sd">    :return: A string representing a specific well on the plate</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">rowVal</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">((</span><span class="n">wellno</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">options</span><span class="o">.</span><span class="n">plate_col_no</span><span class="p">)</span>
    <span class="n">colVal</span> <span class="o">=</span> <span class="p">(</span><span class="n">wellno</span><span class="p">)</span> <span class="o">%</span> <span class="n">options</span><span class="o">.</span><span class="n">plate_col_no</span>
    <span class="k">if</span> <span class="n">colVal</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">colVal</span> <span class="o">=</span> <span class="n">options</span><span class="o">.</span><span class="n">plate_col_no</span>
    
    <span class="n">label</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="nb">chr</span><span class="p">(</span><span class="nb">ord</span><span class="p">(</span><span class="s2">&quot;@&quot;</span><span class="p">)</span><span class="o">+</span><span class="p">(</span><span class="n">rowVal</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="si">}{</span><span class="n">colVal</span><span class="si">}</span><span class="s1">&#39;</span>
    <span class="k">return</span> <span class="n">label</span></div>
    
    
<div class="viewcode-block" id="findHits"><a class="viewcode-back" href="../pyparse_det.html#PyParse.findHits">[docs]</a><span class="k">def</span> <span class="nf">findHits</span><span class="p">(</span><span class="n">compound</span><span class="p">,</span> <span class="n">dataTable</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    For a given compound, look at each peak in each well </span>
<span class="sd">    to find a suitable match based on m/z data.</span>
<span class="sd">    </span>
<span class="sd">    :param compound: A Series corresponding to a specific compound</span>
<span class="sd">                     from the compoundDF pandas dataframe</span>
<span class="sd">    :param dataTable: A dictionary of all peaks in all wells for the plate</span>
<span class="sd">    </span>
<span class="sd">    :return: a list of hits, where each item in the list is a dictionary</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">hits</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">well</span> <span class="ow">in</span> <span class="n">dataTable</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        
        <span class="k">if</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">compound</span><span class="p">[</span><span class="s2">&quot;locations&quot;</span><span class="p">]:</span>
            
            <span class="k">for</span> <span class="n">peak</span> <span class="ow">in</span> <span class="n">dataTable</span><span class="p">[</span><span class="n">index</span><span class="p">]:</span>
                
                <span class="k">if</span> <span class="n">peak</span><span class="p">[</span><span class="s2">&quot;area&quot;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">options</span><span class="o">.</span><span class="n">min_peak_area</span><span class="p">:</span>
                    
                    <span class="n">mass_plus</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="n">mass_minus</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="n">new_hit</span> <span class="o">=</span> <span class="p">{</span>
                            <span class="s2">&quot;time&quot;</span><span class="p">:</span> <span class="n">peak</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">],</span>
                            <span class="s2">&quot;area&quot;</span><span class="p">:</span> <span class="n">peak</span><span class="p">[</span><span class="s2">&quot;area&quot;</span><span class="p">],</span>
                            <span class="s2">&quot;areaAbs&quot;</span><span class="p">:</span> <span class="n">peak</span><span class="p">[</span><span class="s2">&quot;areaAbs&quot;</span><span class="p">],</span>
                            <span class="s2">&quot;UV&quot;</span><span class="p">:</span> <span class="n">peak</span><span class="p">[</span><span class="s2">&quot;UV&quot;</span><span class="p">],</span> 
                            <span class="s2">&quot;well&quot;</span><span class="p">:</span> <span class="n">index</span><span class="p">,</span>
                            <span class="s2">&quot;pStart&quot;</span><span class="p">:</span> <span class="n">peak</span><span class="p">[</span><span class="s2">&quot;pStart&quot;</span><span class="p">],</span>
                            <span class="s2">&quot;pEnd&quot;</span><span class="p">:</span> <span class="n">peak</span><span class="p">[</span><span class="s2">&quot;pEnd&quot;</span><span class="p">],</span>
                            <span class="s2">&quot;mass_conf&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
                            <span class="s2">&quot;mass+&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
                            <span class="s2">&quot;mass-&quot;</span><span class="p">:</span> <span class="mi">0</span>
                            <span class="p">}</span>
                    <span class="n">total_ms_plus</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">peak</span><span class="p">[</span><span class="s2">&quot;MS+&quot;</span><span class="p">]])</span>
                   
                    <span class="k">for</span> <span class="p">[</span><span class="n">mass</span><span class="p">,</span> <span class="n">intensity</span><span class="p">]</span> <span class="ow">in</span> <span class="n">peak</span><span class="p">[</span><span class="s2">&quot;MS+&quot;</span><span class="p">]:</span>
                        <span class="n">intensity_pc</span> <span class="o">=</span> <span class="n">intensity</span><span class="o">/</span><span class="n">total_ms_plus</span> <span class="o">*</span> <span class="mi">100</span>
                        <span class="k">for</span> <span class="n">targetmass</span> <span class="ow">in</span> <span class="p">[</span><span class="n">compound</span><span class="p">[</span><span class="s2">&quot;mass1&quot;</span><span class="p">],</span> <span class="n">compound</span><span class="p">[</span><span class="s2">&quot;mass2&quot;</span><span class="p">],</span> <span class="n">compound</span><span class="p">[</span><span class="s2">&quot;mass3&quot;</span><span class="p">]]:</span>
                            <span class="n">intensity_pc</span> <span class="o">=</span> <span class="n">intensity</span><span class="o">/</span><span class="n">total_ms_plus</span> <span class="o">*</span> <span class="mi">100</span>
                            <span class="k">if</span> <span class="n">math</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">targetmass</span><span class="o">+</span><span class="mf">1.01</span><span class="p">,</span> <span class="n">mass</span><span class="p">,</span> <span class="n">abs_tol</span><span class="o">=</span><span class="n">options</span><span class="o">.</span><span class="n">mass_abs_tol</span><span class="p">):</span>
                                <span class="n">mass_plus</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">mass</span><span class="p">,</span> <span class="n">intensity_pc</span><span class="p">])</span>
                            <span class="k">elif</span> <span class="n">math</span><span class="o">.</span><span class="n">isclose</span><span class="p">((</span><span class="n">targetmass</span><span class="o">+</span><span class="mf">2.02</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">mass</span><span class="p">,</span> <span class="n">abs_tol</span><span class="o">=</span><span class="n">options</span><span class="o">.</span><span class="n">mass_abs_tol</span><span class="p">)</span> <span class="ow">and</span> <span class="n">options</span><span class="o">.</span><span class="n">calc_higherions</span> <span class="o">==</span> <span class="s2">&quot;True&quot;</span><span class="p">:</span>
                                <span class="n">mass_plus</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">mass</span><span class="p">,</span> <span class="n">intensity_pc</span><span class="p">])</span>
                            <span class="k">elif</span> <span class="n">math</span><span class="o">.</span><span class="n">isclose</span><span class="p">((</span><span class="n">targetmass</span><span class="o">+</span><span class="mf">3.03</span><span class="p">)</span><span class="o">/</span><span class="mi">3</span><span class="p">,</span> <span class="n">mass</span><span class="p">,</span> <span class="n">abs_tol</span><span class="o">=</span><span class="n">options</span><span class="o">.</span><span class="n">mass_abs_tol</span><span class="p">)</span> <span class="ow">and</span> <span class="n">options</span><span class="o">.</span><span class="n">calc_higherions</span> <span class="o">==</span> <span class="s2">&quot;True&quot;</span><span class="p">:</span>
                                <span class="n">mass_plus</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">mass</span><span class="p">,</span> <span class="n">intensity_pc</span><span class="p">])</span>

                                
                    <span class="n">total_ms_minus</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">peak</span><span class="p">[</span><span class="s2">&quot;MS-&quot;</span><span class="p">]])</span>        
                    <span class="k">for</span> <span class="p">[</span><span class="n">mass</span><span class="p">,</span> <span class="n">intensity</span><span class="p">]</span> <span class="ow">in</span> <span class="n">peak</span><span class="p">[</span><span class="s2">&quot;MS-&quot;</span><span class="p">]:</span>
                        <span class="k">for</span> <span class="n">targetmass</span> <span class="ow">in</span> <span class="p">[</span><span class="n">compound</span><span class="p">[</span><span class="s2">&quot;mass1&quot;</span><span class="p">],</span> <span class="n">compound</span><span class="p">[</span><span class="s2">&quot;mass2&quot;</span><span class="p">],</span> <span class="n">compound</span><span class="p">[</span><span class="s2">&quot;mass3&quot;</span><span class="p">]]:</span>
                            <span class="n">intensity_pc</span> <span class="o">=</span> <span class="n">intensity</span><span class="o">/</span><span class="n">total_ms_minus</span> <span class="o">*</span> <span class="mi">100</span>
                            <span class="k">if</span> <span class="n">math</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">targetmass</span><span class="o">-</span><span class="mf">1.01</span><span class="p">,</span> <span class="n">mass</span><span class="p">,</span> <span class="n">abs_tol</span><span class="o">=</span><span class="n">options</span><span class="o">.</span><span class="n">mass_abs_tol</span><span class="p">):</span>
                                <span class="n">mass_minus</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">mass</span><span class="p">,</span> <span class="n">intensity_pc</span><span class="p">])</span>
                    
                    <span class="c1">#If the total mass confidence for this peak/compound pair </span>
                    <span class="c1">#is greater than min_massconf_threshold, store this peak</span>
                    <span class="c1">#The peak is also stored if the retention time of the hit is close</span>
                    <span class="c1">#to that specified in the platemap (if one was specified) - this </span>
                    <span class="c1">#allows compounds that don&#39;t ionise to still be analysed</span>
                    
                    <span class="n">total_mc</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">mass_plus</span><span class="p">])</span> <span class="o">+</span> <span class="nb">sum</span><span class="p">([</span><span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">mass_minus</span><span class="p">])</span>

                    <span class="k">if</span> <span class="n">total_mc</span> <span class="o">&gt;</span> <span class="n">options</span><span class="o">.</span><span class="n">min_massconf_threshold</span> <span class="ow">or</span> <span class="n">math</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">new_hit</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">],</span> <span class="n">compound</span><span class="p">[</span><span class="s2">&quot;rt&quot;</span><span class="p">],</span> <span class="n">abs_tol</span><span class="o">=</span><span class="n">options</span><span class="o">.</span><span class="n">time_abs_tol</span><span class="p">):</span>
                        <span class="n">new_hit</span><span class="p">[</span><span class="s2">&quot;mass_conf&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">total_mc</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mass_plus</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">new_hit</span><span class="p">[</span><span class="s2">&quot;mass+&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">mass_plus</span><span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="k">else</span><span class="p">:</span> 
                            <span class="n">new_hit</span><span class="p">[</span><span class="s2">&quot;mass+&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;-&quot;</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mass_minus</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">new_hit</span><span class="p">[</span><span class="s2">&quot;mass-&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">mass_minus</span><span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">new_hit</span><span class="p">[</span><span class="s2">&quot;mass-&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;-&quot;</span>

                        <span class="n">hits</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_hit</span><span class="p">)</span>
            
    <span class="k">return</span> <span class="n">hits</span></div>

<div class="viewcode-block" id="refineClusterByTime"><a class="viewcode-back" href="../pyparse_det.html#PyParse.refineClusterByTime">[docs]</a><span class="k">def</span> <span class="nf">refineClusterByTime</span><span class="p">(</span><span class="n">cluster</span><span class="p">,</span> <span class="n">comments</span><span class="p">,</span> <span class="n">expected_rt</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Takes in input cluster of all the hit peaks, </span>
<span class="sd">    and refines them by finding a mid-value for the retention</span>
<span class="sd">    time based on which hit has the greatest number of nearest neighbours. </span>
<span class="sd">    Sorts the best hits into &quot;green&quot;, uncertain ones into &quot;orange&quot; </span>
<span class="sd">    and those where another peak closer to the mid-value was found</span>
<span class="sd">    in the same well into &quot;discarded&quot;. </span>
<span class="sd">    </span>
<span class="sd">    :param cluster: list of dictionaries, where each dictionary is a hit</span>
<span class="sd">    :param comments: A list of comments for that structure so far.</span>
<span class="sd">    </span>
<span class="sd">    :return: List comprising [a dictionary for the refined cluster, list of comments]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">refined_cluster</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;green&quot;</span><span class="p">:[],</span>
            <span class="s2">&quot;orange&quot;</span><span class="p">:</span> <span class="p">[],</span>
            <span class="s2">&quot;discarded&quot;</span><span class="p">:</span> <span class="p">[],</span>
            <span class="p">}</span>
    
    <span class="n">mid_values</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">mid_value</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">if</span> <span class="n">expected_rt</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">mid_value</span> <span class="o">=</span> <span class="n">expected_rt</span>
    <span class="k">else</span><span class="p">:</span> 
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">cluster</span><span class="p">:</span>
            <span class="n">mid_value</span> <span class="o">=</span> <span class="n">i</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">]</span>
            <span class="n">mid_values</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">mid_value</span><span class="p">,</span> <span class="nb">len</span><span class="p">([</span><span class="n">j</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">cluster</span> <span class="k">if</span> <span class="n">math</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">j</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">],</span> <span class="n">mid_value</span><span class="p">,</span> <span class="n">abs_tol</span> <span class="o">=</span> <span class="n">options</span><span class="o">.</span><span class="n">time_abs_tol</span><span class="o">/</span><span class="mi">4</span><span class="p">)])])</span>
        <span class="n">mid_value</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">mid_values</span><span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
    
    <span class="c1">#sort the peaks by the well they occupy</span>
    <span class="n">peaks_by_wells</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">peak</span> <span class="ow">in</span> <span class="n">cluster</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">peak</span><span class="p">[</span><span class="s2">&quot;well&quot;</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">peaks_by_wells</span><span class="p">:</span>
            <span class="n">peaks_by_wells</span><span class="p">[</span><span class="n">peak</span><span class="p">[</span><span class="s2">&quot;well&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">peaks_by_wells</span><span class="p">[</span><span class="n">peak</span><span class="p">[</span><span class="s2">&quot;well&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">peak</span><span class="p">)</span>
    
    <span class="c1">#For each well, select the peak that&#39;s closest to the mid-value in cases</span>
    <span class="c1">#where there was more than one hit in that cluster in one well</span>
    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">well</span> <span class="ow">in</span> <span class="n">peaks_by_wells</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">well</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">min_diff</span> <span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">]</span><span class="o">-</span><span class="n">mid_value</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">well</span><span class="p">])</span>
            
            <span class="k">for</span> <span class="n">peak</span> <span class="ow">in</span> <span class="n">well</span><span class="p">:</span>
                
                <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">peak</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">]</span><span class="o">-</span><span class="n">mid_value</span><span class="p">)</span> <span class="o">==</span> <span class="n">min_diff</span><span class="p">:</span>
                    <span class="n">refined_cluster</span><span class="p">[</span><span class="s2">&quot;green&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">peak</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">refined_cluster</span><span class="p">[</span><span class="s2">&quot;discarded&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">peak</span><span class="p">)</span>
                    <span class="n">comments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Peak at </span><span class="si">{</span><span class="n">peak</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">]</span><span class="si">}</span><span class="s1"> &#39;</span>
                                <span class="sa">f</span><span class="s1">&#39;in well </span><span class="si">{</span><span class="n">getUserReadableWell</span><span class="p">(</span><span class="n">peak</span><span class="p">[</span><span class="s2">&quot;well&quot;</span><span class="p">])</span><span class="si">}</span><span class="s1"> was discarded &#39;</span>
                                <span class="s1">&#39;as there was an alternative peak &#39;</span>
                                <span class="s1">&#39;in the same well which was closer to the &#39;</span>
                                <span class="s1">&#39;mid-point of the cluster.&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">refined_cluster</span><span class="p">[</span><span class="s2">&quot;green&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">well</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="c1">#Refine these hits further by finding those which are within time_abs_tol/2</span>
    <span class="c1">#of the mid-value. Any others are marked as tentative and the user is alerted.         </span>
    <span class="n">ref2_cluster</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;green&quot;</span><span class="p">:[],</span>
            <span class="s2">&quot;orange&quot;</span><span class="p">:</span> <span class="n">refined_cluster</span><span class="p">[</span><span class="s2">&quot;orange&quot;</span><span class="p">],</span>
            <span class="s2">&quot;discarded&quot;</span><span class="p">:</span> <span class="n">refined_cluster</span><span class="p">[</span><span class="s2">&quot;discarded&quot;</span><span class="p">],</span>
            <span class="p">}</span>        
            
    <span class="k">for</span> <span class="n">peak</span> <span class="ow">in</span> <span class="n">refined_cluster</span><span class="p">[</span><span class="s2">&quot;green&quot;</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">math</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">peak</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">],</span> <span class="n">mid_value</span><span class="p">,</span> <span class="n">abs_tol</span> <span class="o">=</span> <span class="n">options</span><span class="o">.</span><span class="n">time_abs_tol</span> <span class="o">/</span> <span class="mi">2</span><span class="p">):</span>
            <span class="n">ref2_cluster</span><span class="p">[</span><span class="s2">&quot;green&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">peak</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ref2_cluster</span><span class="p">[</span><span class="s2">&quot;orange&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">peak</span><span class="p">)</span>
            <span class="n">comments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Peak at </span><span class="si">{</span><span class="n">peak</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">]</span><span class="si">}</span><span class="s1"> in &#39;</span>
                           <span class="sa">f</span><span class="s1">&#39;well </span><span class="si">{</span><span class="n">getUserReadableWell</span><span class="p">(</span><span class="n">peak</span><span class="p">[</span><span class="s2">&quot;well&quot;</span><span class="p">])</span><span class="si">}</span><span class="s1"> was &#39;</span>
                           <span class="s1">&#39;marked as tentative as it was found to be too &#39;</span>
                           <span class="s1">&#39;far from the mid-value of the cluster.&#39;</span><span class="p">)</span>
    
    
    <span class="k">return</span> <span class="p">[</span><span class="n">ref2_cluster</span><span class="p">,</span> <span class="n">comments</span><span class="p">]</span></div>
                        
    
    
<div class="viewcode-block" id="refineClusterByUV"><a class="viewcode-back" href="../pyparse_det.html#PyParse.refineClusterByUV">[docs]</a><span class="k">def</span> <span class="nf">refineClusterByUV</span><span class="p">(</span><span class="n">cluster</span><span class="p">,</span> <span class="n">UVdatafound</span><span class="p">,</span> <span class="n">comments</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Takes in input cluster of all the hit peaks, </span>
<span class="sd">    and refines the cluster by ensuring all peaks have a similar set</span>
<span class="sd">    of UV maxima. Those which do are left in &quot;green&quot;, those which</span>
<span class="sd">    don&#39;t are moved to the &quot;orange&quot; category</span>
<span class="sd">    </span>
<span class="sd">    :param cluster: a dict, with list of dicts for each header</span>
<span class="sd">    :param UVdatafound: boolean for whether the rpt data contains UV data</span>
<span class="sd">    :param comments: A list of comments for that structure so far</span>
<span class="sd">    </span>
<span class="sd">    :return: List comprising [a dictionary for the refined cluster, list of comments]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">refined_cluster</span> <span class="o">=</span> <span class="p">{</span>
                        <span class="s2">&quot;green&quot;</span><span class="p">:</span> <span class="p">[],</span>
                        <span class="s2">&quot;orange&quot;</span><span class="p">:</span> <span class="n">cluster</span><span class="p">[</span><span class="s2">&quot;orange&quot;</span><span class="p">],</span>
                        <span class="s2">&quot;discarded&quot;</span><span class="p">:</span> <span class="n">cluster</span><span class="p">[</span><span class="s2">&quot;discarded&quot;</span><span class="p">],</span>
                        <span class="p">}</span>
    
    <span class="k">if</span> <span class="n">UVdatafound</span> <span class="o">==</span> <span class="kc">True</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">cluster</span><span class="p">[</span><span class="s2">&quot;green&quot;</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">UVclusters</span> <span class="o">=</span> <span class="p">[]</span>
        
        <span class="k">for</span> <span class="n">peak</span> <span class="ow">in</span> <span class="n">cluster</span><span class="p">[</span><span class="s2">&quot;green&quot;</span><span class="p">]:</span>
            <span class="k">for</span> <span class="n">UV</span> <span class="ow">in</span> <span class="n">peak</span><span class="p">[</span><span class="s2">&quot;UV&quot;</span><span class="p">]:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">UVclusters</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">UVclusters</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">UV</span><span class="p">])</span>
                    
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">clusterFound</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">for</span> <span class="n">UVcluster</span> <span class="ow">in</span> <span class="n">UVclusters</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">math</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">UVcluster</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">UV</span><span class="p">,</span> <span class="n">abs_tol</span><span class="o">=</span><span class="n">options</span><span class="o">.</span><span class="n">uv_abs_tol</span><span class="p">):</span>
                            <span class="n">UVcluster</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">UV</span><span class="p">)</span>
                            <span class="n">clusterFound</span> <span class="o">=</span> <span class="kc">True</span>
                            <span class="k">break</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">clusterFound</span><span class="p">:</span>
                        <span class="n">UVclusters</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">UV</span><span class="p">])</span>
           
        <span class="n">meanUV</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1">#Check to ensure UVclusters isn&#39;t an empty set</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">UVclusters</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">lengthOfMostCommon</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">UVcluster</span><span class="p">)</span> <span class="k">for</span> <span class="n">UVcluster</span> <span class="ow">in</span> <span class="n">UVclusters</span><span class="p">])</span>

            <span class="k">for</span> <span class="n">UVcluster</span> <span class="ow">in</span> <span class="n">UVclusters</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">UVcluster</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">lengthOfMostCommon</span> <span class="o">*</span> <span class="n">options</span><span class="o">.</span><span class="n">uv_cluster_threshold</span><span class="p">:</span>
                    <span class="n">meanUV</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mean</span><span class="p">(</span><span class="n">UVcluster</span><span class="p">))</span>
            
            <span class="k">for</span> <span class="n">peak</span> <span class="ow">in</span> <span class="n">cluster</span><span class="p">[</span><span class="s2">&quot;green&quot;</span><span class="p">]:</span>
                
                <span class="n">intersection</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">meanvalue</span> <span class="ow">in</span> <span class="n">meanUV</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">UV</span> <span class="ow">in</span> <span class="n">peak</span><span class="p">[</span><span class="s2">&quot;UV&quot;</span><span class="p">]:</span>
                        <span class="k">if</span> <span class="n">math</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">meanvalue</span><span class="p">,</span> <span class="n">UV</span><span class="p">,</span> <span class="n">abs_tol</span> <span class="o">=</span> <span class="n">options</span><span class="o">.</span><span class="n">uv_abs_tol</span><span class="p">):</span>
                            <span class="n">intersection</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">meanvalue</span><span class="p">)</span>
                            
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">intersection</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">meanUV</span><span class="p">)</span> <span class="o">*</span> <span class="n">options</span><span class="o">.</span><span class="n">uv_match_threshold</span><span class="p">:</span>
                    <span class="n">refined_cluster</span><span class="p">[</span><span class="s2">&quot;green&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">peak</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">refined_cluster</span><span class="p">[</span><span class="s2">&quot;orange&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">peak</span><span class="p">)</span>
                    <span class="n">comments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Peak at </span><span class="si">{</span><span class="n">peak</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">]</span><span class="si">}</span><span class="s1"> in well </span><span class="si">{</span><span class="n">getUserReadableWell</span><span class="p">(</span><span class="n">peak</span><span class="p">[</span><span class="s2">&quot;well&quot;</span><span class="p">])</span><span class="si">}</span><span class="s1"> &#39;</span>
                    <span class="sa">f</span><span class="s1">&#39;was marked tentative due to mismatch in UV maxima with the rest of the cluster.&#39;</span><span class="p">)</span>
        <span class="c1">#If UVclusters is an empty set, pass through the original hits without further</span>
        <span class="c1">#validation. </span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">comments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;UV validation not permitted where cluster contains peaks with no UV data. &#39;</span>
                <span class="s1">&#39;UV validation was not performed.&#39;</span><span class="p">)</span>
            <span class="n">refined_cluster</span><span class="p">[</span><span class="s2">&quot;green&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cluster</span><span class="p">[</span><span class="s2">&quot;green&quot;</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">comments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;UV data was not found for the plate, so UV validation was not performed.&#39;</span><span class="p">)</span>
        <span class="n">refined_cluster</span><span class="p">[</span><span class="s2">&quot;green&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cluster</span><span class="p">[</span><span class="s2">&quot;green&quot;</span><span class="p">]</span>        
            
    <span class="k">return</span> <span class="p">[</span><span class="n">refined_cluster</span><span class="p">,</span> <span class="n">comments</span><span class="p">]</span></div>
    
<div class="viewcode-block" id="refineClusterByMassConf"><a class="viewcode-back" href="../pyparse_det.html#PyParse.refineClusterByMassConf">[docs]</a><span class="k">def</span> <span class="nf">refineClusterByMassConf</span><span class="p">(</span><span class="n">cluster</span><span class="p">,</span> <span class="n">comments</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Takes in input cluster of all the hit peaks, </span>
<span class="sd">    and refines them by ensuring all peaks have a similar mass confidence</span>
<span class="sd">    to the cluster&#39;s mean. Those which do are left in &quot;green&quot;; </span>
<span class="sd">    those which don&#39;t are moved to the &quot;orange&quot; category.</span>
<span class="sd">    </span>
<span class="sd">    :param cluster: a dict, with list of dicts for each header</span>
<span class="sd">    :param comments: A list of comments for the compound so far</span>
<span class="sd">    </span>
<span class="sd">    :return: List comprising [a dictionary for the refined cluster, list of comments]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">refined_cluster</span> <span class="o">=</span> <span class="p">{</span>
                        <span class="s2">&quot;green&quot;</span><span class="p">:</span> <span class="p">[],</span>
                        <span class="s2">&quot;orange&quot;</span><span class="p">:</span> <span class="n">cluster</span><span class="p">[</span><span class="s2">&quot;orange&quot;</span><span class="p">],</span>
                        <span class="s2">&quot;discarded&quot;</span><span class="p">:</span> <span class="n">cluster</span><span class="p">[</span><span class="s2">&quot;discarded&quot;</span><span class="p">],</span>
                        <span class="p">}</span>
    <span class="c1">#find what the mean mass confidence is of all peaks</span>
    <span class="c1">#currently under the &quot;green&quot; category</span>
    <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">mean</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cluster</span><span class="p">[</span><span class="s2">&quot;green&quot;</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">peak</span> <span class="ow">in</span> <span class="n">cluster</span><span class="p">[</span><span class="s2">&quot;green&quot;</span><span class="p">]:</span>
            <span class="n">total</span> <span class="o">+=</span> <span class="n">peak</span><span class="p">[</span><span class="s2">&quot;mass_conf&quot;</span><span class="p">]</span>
        <span class="n">mean</span> <span class="o">=</span> <span class="n">total</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">cluster</span><span class="p">[</span><span class="s2">&quot;green&quot;</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">peak</span> <span class="ow">in</span> <span class="n">cluster</span><span class="p">[</span><span class="s2">&quot;orange&quot;</span><span class="p">]:</span>
            <span class="n">total</span> <span class="o">+=</span> <span class="n">peak</span><span class="p">[</span><span class="s2">&quot;mass_conf&quot;</span><span class="p">]</span>
        <span class="n">mean</span> <span class="o">=</span> <span class="n">total</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">cluster</span><span class="p">[</span><span class="s2">&quot;orange&quot;</span><span class="p">])</span>
    
    
    
    <span class="k">for</span> <span class="n">peak</span> <span class="ow">in</span> <span class="n">cluster</span><span class="p">[</span><span class="s2">&quot;green&quot;</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">peak</span><span class="p">[</span><span class="s2">&quot;mass_conf&quot;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">mean</span> <span class="o">*</span> <span class="n">options</span><span class="o">.</span><span class="n">massconf_threshold</span><span class="p">:</span>
            <span class="n">refined_cluster</span><span class="p">[</span><span class="s2">&quot;orange&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">peak</span><span class="p">)</span>
            <span class="n">comments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Peak at </span><span class="si">{</span><span class="n">peak</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">]</span><span class="si">}</span><span class="s1"> in well </span><span class="si">{</span><span class="n">getUserReadableWell</span><span class="p">(</span><span class="n">peak</span><span class="p">[</span><span class="s2">&quot;well&quot;</span><span class="p">])</span><span class="si">}</span><span class="s1"> &#39;</span>
                  <span class="sa">f</span><span class="s1">&#39;was marked tentative due to poor mass confidence in comparison to the rest of the cluster.&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">refined_cluster</span><span class="p">[</span><span class="s2">&quot;green&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">peak</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="p">[</span><span class="n">refined_cluster</span><span class="p">,</span> <span class="n">comments</span><span class="p">]</span></div>

<div class="viewcode-block" id="selectClusterByMassConf"><a class="viewcode-back" href="../pyparse_det.html#PyParse.selectClusterByMassConf">[docs]</a><span class="k">def</span> <span class="nf">selectClusterByMassConf</span><span class="p">(</span><span class="n">clusters</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    If more than one cluster was found for the compound, </span>
<span class="sd">    this function is called to try to select a single cluster based on </span>
<span class="sd">    which cluster has the highest mean massConf. If more than one cluster</span>
<span class="sd">    has a close-to-highest-mean massconf, take them all. </span>
<span class="sd">    </span>
<span class="sd">    :param clusters: a list of dictionaries, with list of dictionaries for each header</span>
<span class="sd">    :return refined_clusters: a list of dictionaries, with list of dictionaries for each header</span>
<span class="sd">    </span>
<span class="sd">    :return discarded_clusters: a list of dictionaries, with list of dictionaries for each header</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">refined_clusters</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">discarded_clusters</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="n">means</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1">#find the mean massconf for each cluster</span>
    <span class="k">for</span> <span class="n">cluster</span> <span class="ow">in</span> <span class="n">clusters</span><span class="p">:</span>
        <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">peak</span> <span class="ow">in</span> <span class="n">cluster</span><span class="p">[</span><span class="s2">&quot;green&quot;</span><span class="p">]:</span>
            <span class="n">total</span> <span class="o">+=</span> <span class="n">peak</span><span class="p">[</span><span class="s2">&quot;mass_conf&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">total</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">mean</span> <span class="o">=</span> <span class="n">total</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">cluster</span><span class="p">[</span><span class="s2">&quot;green&quot;</span><span class="p">])</span>
            <span class="n">means</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mean</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">means</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="c1">#find the maximum mean value to compare all clusters against</span>
    <span class="n">max_mean</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">means</span><span class="p">)</span>
    
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">means</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">max_mean</span> <span class="o">*</span> <span class="n">options</span><span class="o">.</span><span class="n">massconf_threshold</span> <span class="o">&lt;</span> <span class="n">means</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">or</span> <span class="p">(</span><span class="n">max_mean</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">means</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
            <span class="n">refined_clusters</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">clusters</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">discarded_clusters</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">clusters</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            
    <span class="k">return</span> <span class="p">[</span><span class="n">refined_clusters</span><span class="p">,</span> <span class="n">discarded_clusters</span><span class="p">]</span></div>
            
<div class="viewcode-block" id="selectClusterBySize"><a class="viewcode-back" href="../pyparse_det.html#PyParse.selectClusterBySize">[docs]</a><span class="k">def</span> <span class="nf">selectClusterBySize</span><span class="p">(</span><span class="n">clusters</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    If more than one cluster was found for the compound, </span>
<span class="sd">    this function is called to try to select a single cluster based on </span>
<span class="sd">    which cluster is the largest. If more than one cluster</span>
<span class="sd">    has a close-to-largest size, take them all. </span>
<span class="sd">    </span>
<span class="sd">    :param clusters: a list of dictionaries, with list of dictionaries for each header</span>
<span class="sd">    :return refined_clusters: a list of dictionaries, with list of dictionaries for each header</span>
<span class="sd">    </span>
<span class="sd">    :return discarded_clusters: a list of dictionaries, with list of dictionaries for each header</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">refined_clusters</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">discarded_clusters</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="n">lengths</span> <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">cluster</span><span class="p">[</span><span class="s2">&quot;green&quot;</span><span class="p">])</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">cluster</span><span class="p">[</span><span class="s2">&quot;orange&quot;</span><span class="p">])</span> <span class="k">for</span> <span class="n">cluster</span> <span class="ow">in</span> <span class="n">clusters</span><span class="p">]</span>
    <span class="n">max_length</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">lengths</span><span class="p">)</span>
    
    <span class="k">for</span> <span class="n">cluster</span> <span class="ow">in</span> <span class="n">clusters</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cluster</span><span class="p">[</span><span class="s2">&quot;green&quot;</span><span class="p">])</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">cluster</span><span class="p">[</span><span class="s2">&quot;orange&quot;</span><span class="p">])</span> <span class="o">&gt;</span> <span class="n">max_length</span> <span class="o">*</span> <span class="n">options</span><span class="o">.</span><span class="n">cluster_size_threshold</span><span class="p">:</span>
            <span class="n">refined_clusters</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cluster</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">discarded_clusters</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cluster</span><span class="p">)</span>
            
    <span class="c1">#If there is still more than one cluster, repeat the process using only those peaks</span>
    <span class="c1">#that haven&#39;t been marked as suspicious</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">refined_clusters</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        
        <span class="n">lengths</span> <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">cluster</span><span class="p">[</span><span class="s2">&quot;green&quot;</span><span class="p">])</span> <span class="k">for</span> <span class="n">cluster</span> <span class="ow">in</span> <span class="n">clusters</span><span class="p">]</span>
        <span class="n">max_length</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">lengths</span><span class="p">)</span>
        
        <span class="c1">#As long as at least one cluster had a green hit, filter the clusters by size</span>
        <span class="k">if</span> <span class="n">max_length</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">refined_clusters</span> <span class="o">=</span> <span class="p">[]</span>
            
            <span class="k">for</span> <span class="n">cluster</span> <span class="ow">in</span> <span class="n">clusters</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cluster</span><span class="p">[</span><span class="s2">&quot;green&quot;</span><span class="p">])</span> <span class="o">&gt;</span> <span class="n">max_length</span> <span class="o">*</span> <span class="n">options</span><span class="o">.</span><span class="n">cluster_size_threshold</span><span class="p">:</span>
                    <span class="n">refined_clusters</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cluster</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">discarded_clusters</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cluster</span><span class="p">)</span>
            
    <span class="k">return</span> <span class="p">[</span><span class="n">refined_clusters</span><span class="p">,</span> <span class="n">discarded_clusters</span><span class="p">]</span>    </div>

<div class="viewcode-block" id="validateHits"><a class="viewcode-back" href="../pyparse_det.html#PyParse.validateHits">[docs]</a><span class="k">def</span> <span class="nf">validateHits</span><span class="p">(</span><span class="n">cpname</span><span class="p">,</span> <span class="n">peakList</span><span class="p">,</span> <span class="n">expected_rt</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Looks at all hits for a given compound, and refines</span>
<span class="sd">    the list based on retention time, massConf and UV data. </span>
<span class="sd">    The goal is to end up with only high confidence hits, and no more than</span>
<span class="sd">    one hit per well. </span>
<span class="sd">    </span>
<span class="sd">    :param cpname: string of the compound name</span>
<span class="sd">    :param peakList: A list of all hits for (peaks assigned to) that compound</span>
<span class="sd">    :param expected_rt: An integer for the expected retention time of the compound</span>
<span class="sd">    </span>
<span class="sd">    :return: A dictionary, where each header contains a list of dictionaries (peaks), </span>
<span class="sd">            along with other useful variables to aid plot generation. </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#Initialise variables which end up in the final output</span>
    <span class="n">output</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;green&quot;</span><span class="p">:</span> <span class="p">[],</span>
            <span class="s2">&quot;discarded&quot;</span><span class="p">:</span> <span class="p">[],</span>
            <span class="s2">&quot;discarded_by_cluster&quot;</span><span class="p">:</span> <span class="p">[]</span>
        <span class="p">}</span>
    <span class="n">comment_text</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">mean_time</span> <span class="o">=</span> <span class="mi">0</span>
    
    
    <span class="c1">#Store the mean retention times of each </span>
    <span class="c1">#cluster to enable annotation in the output plots. </span>
    <span class="n">cluster_bands</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="c1">#check to see if UV data is available to validate against</span>
    <span class="n">UVdatafound</span> <span class="o">=</span> <span class="kc">True</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">peakList</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;UV&quot;</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="kc">False</span>

    <span class="c1">#find how many wells have at least one hit:</span>
    <span class="n">hitwells</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">i</span><span class="p">[</span><span class="s2">&quot;well&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">peakList</span><span class="p">])</span>
    
    <span class="n">comment_text</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">peakList</span><span class="p">)</span><span class="si">}</span><span class="s1"> hits were found for </span><span class="si">{</span><span class="n">cpname</span><span class="si">}</span><span class="s1">.&#39;</span><span class="p">)</span>
    
    <span class="n">clusters</span> <span class="o">=</span> <span class="p">[]</span>
        
    <span class="c1">#lambda: inline function definition</span>
    <span class="c1">#sort the peaks in order of ascending retention time</span>
    
    <span class="n">peakList</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">])</span>
    
    <span class="c1">#cluster the peaks by retention time into groups to better</span>
    <span class="c1">#classify which hits are likely to be genuine and which</span>
    <span class="c1">#are false positives. </span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">peakList</span><span class="p">)):</span>
        
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">clusters</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">clusters</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">peakList</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">clusterFound</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">for</span> <span class="n">cluster</span> <span class="ow">in</span> <span class="n">clusters</span><span class="p">:</span>
                <span class="n">mean_rt</span> <span class="o">=</span> <span class="n">mean</span><span class="p">([</span><span class="n">i</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">cluster</span><span class="p">])</span>
                
                <span class="k">if</span> <span class="n">math</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">mean_rt</span><span class="p">,</span> <span class="n">peakList</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s2">&quot;time&quot;</span><span class="p">],</span> <span class="n">abs_tol</span><span class="o">=</span><span class="n">options</span><span class="o">.</span><span class="n">time_abs_tol</span><span class="p">):</span>
                    <span class="n">cluster</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">peakList</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                    <span class="n">clusterFound</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">break</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">clusterFound</span><span class="p">:</span>
                <span class="n">clusters</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">peakList</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>
                
    <span class="n">comment_text</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">clusters</span><span class="p">)</span><span class="si">}</span><span class="s1"> clusters were found for </span><span class="si">{</span><span class="n">cpname</span><span class="si">}</span><span class="s1">.&#39;</span><span class="p">)</span>
    
    <span class="c1">#find the average retention time for each cluster, and store in cluster_bands</span>
    <span class="c1">#use this to label the hit validation graph and to refine by expected_rt.  </span>
    
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">clusters</span><span class="p">)):</span>
        <span class="n">avg_time</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">j</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">clusters</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">clusters</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">cluster_bands</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">avg_time</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span>
        
        <span class="k">for</span> <span class="n">peak</span> <span class="ow">in</span> <span class="n">clusters</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="n">peak</span><span class="p">[</span><span class="s2">&quot;cluster&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
    
    <span class="c1">#If the user has specified a retention time, we should select only the cluster </span>
    <span class="c1">#that is closest to that retention time, and within options.time_abs_tol</span>
    <span class="k">if</span> <span class="n">expected_rt</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">suitable_clusters</span> <span class="o">=</span> <span class="p">[</span><span class="n">index</span> <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cluster_bands</span><span class="p">)</span> <span class="k">if</span> <span class="n">math</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">expected_rt</span><span class="p">,</span>
                                                                <span class="n">abs_tol</span><span class="o">=</span><span class="n">options</span><span class="o">.</span><span class="n">time_abs_tol</span><span class="p">)]</span>
        
        <span class="c1">#If there is more than one cluster close to the specified retention time</span>
        <span class="c1">#take only the cluster which is closest </span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">suitable_clusters</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">diffs</span> <span class="o">=</span> <span class="p">[</span><span class="n">cluster_bands</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">-</span><span class="n">expected_rt</span> <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">suitable_clusters</span><span class="p">]</span>
            <span class="n">index_min</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">diffs</span><span class="p">)),</span> <span class="n">key</span><span class="o">=</span><span class="n">diffs</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">)</span>
            <span class="n">clusters</span> <span class="o">=</span> <span class="p">[</span><span class="n">clusters</span><span class="p">[</span><span class="n">suitable_clusters</span><span class="p">[</span><span class="n">index_min</span><span class="p">]]]</span>
            <span class="c1">#Update the cluster bands to only include the correct label</span>
            <span class="n">cluster_bands</span> <span class="o">=</span> <span class="p">[</span><span class="n">cluster_bands</span><span class="p">[</span><span class="n">suitable_clusters</span><span class="p">[</span><span class="n">index_min</span><span class="p">]]]</span>

            <span class="n">comment_text</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;&lt;strong&gt;Multiple clusters were found close the specified&quot;</span>
                                <span class="s2">&quot; retention time.&lt;/strong&gt;&quot;</span><span class="p">)</span>
            <span class="n">comment_text</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;&lt;strong&gt;Cluster </span><span class="si">{</span><span class="n">index_min</span><span class="si">}</span><span class="s1"> was selected as it was closest&#39;</span>
                                <span class="s1">&#39; to the specified retention time.&lt;/strong&gt;&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">suitable_clusters</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">clusters</span> <span class="o">=</span> <span class="p">[</span><span class="n">clusters</span><span class="p">[</span><span class="n">suitable_clusters</span><span class="p">[</span><span class="mi">0</span><span class="p">]]]</span>
            <span class="n">cluster_bands</span> <span class="o">=</span> <span class="p">[</span><span class="n">cluster_bands</span><span class="p">[</span><span class="n">suitable_clusters</span><span class="p">[</span><span class="mi">0</span><span class="p">]]]</span>
            <span class="n">comment_text</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;&lt;strong&gt;A single cluster was found close the specified&quot;</span>
                                <span class="s2">&quot; retention time and this was selected for analysis.&lt;/strong&gt;&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">comment_text</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;&lt;strong&gt;No cluster was found near to the specified &quot;</span>
                                <span class="s2">&quot;retention time. Proceeding with analysis using all &quot;</span>
                                <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">clusters</span><span class="p">)</span><span class="si">}</span><span class="s1"> clusters.&lt;/strong&gt;&#39;</span><span class="p">)</span>
    
    
    <span class="c1">#Note: if options.validate is set to true, validation may still run </span>
    <span class="c1">#using the one cluster identified from the given retention time</span>
    <span class="c1">#(assuming one was)      </span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">hitwells</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">options</span><span class="o">.</span><span class="n">min_no_of_wells</span> <span class="ow">and</span> <span class="n">options</span><span class="o">.</span><span class="n">validate</span> <span class="o">==</span> <span class="s2">&quot;True&quot;</span><span class="p">:</span>
           
        <span class="c1">#iterate through the clusters and refine each cluster</span>
        <span class="c1">#by time, then by UV, then by massconf.</span>
        <span class="n">refined_clusters</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">clusters</span><span class="p">)):</span>
            
            <span class="c1">#Refine using the retention time of the hits</span>
            <span class="n">ref_cluster</span> <span class="o">=</span> <span class="n">refineClusterByTime</span><span class="p">(</span><span class="n">clusters</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">comment_text</span><span class="p">,</span> <span class="n">expected_rt</span><span class="p">)</span>
            <span class="n">comment_text</span> <span class="o">=</span> <span class="n">ref_cluster</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>   
            <span class="n">comment_text</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">ref_cluster</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;discarded&quot;</span><span class="p">])</span><span class="si">}</span><span class="s1"> hits were &#39;</span>
                            <span class="sa">f</span><span class="s1">&#39;discarded from cluster </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1"> for </span><span class="si">{</span><span class="n">cpname</span><span class="si">}</span><span class="s1"> as &#39;</span>
                            <span class="s1">&#39;a result of refinement by retention time.&#39;</span><span class="p">)</span>
            
            <span class="c1">#Refine by the UV maxima of the hits</span>
            <span class="n">ref2_cluster</span> <span class="o">=</span> <span class="n">refineClusterByUV</span><span class="p">(</span><span class="n">ref_cluster</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">UVdatafound</span><span class="p">,</span> <span class="n">comment_text</span><span class="p">)</span>
            <span class="n">comment_text</span> <span class="o">=</span> <span class="n">ref2_cluster</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">initial_length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ref_cluster</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;orange&quot;</span><span class="p">])</span>
            <span class="n">comment_text</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">ref2_cluster</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;orange&quot;</span><span class="p">])</span> <span class="o">-</span> <span class="n">initial_length</span><span class="si">}</span><span class="s1">&#39;</span>
                                <span class="sa">f</span><span class="s1">&#39; hits were marked as tentative from cluster </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1"> &#39;</span>
                                <span class="sa">f</span><span class="s1">&#39;for </span><span class="si">{</span><span class="n">cpname</span><span class="si">}</span><span class="s1"> as a result of refinement by UV maxima.&#39;</span><span class="p">)</span> 
            
            <span class="c1">#Refine using the mass confidence of the hits</span>
            <span class="n">ref3_cluster</span> <span class="o">=</span> <span class="n">refineClusterByMassConf</span><span class="p">(</span><span class="n">ref2_cluster</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">comment_text</span><span class="p">)</span>
            <span class="n">comment_text</span> <span class="o">=</span> <span class="n">ref3_cluster</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">initial_length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ref2_cluster</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;orange&quot;</span><span class="p">])</span>
            <span class="n">comment_text</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">ref3_cluster</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;orange&quot;</span><span class="p">])</span> <span class="o">-</span> <span class="n">initial_length</span><span class="si">}</span><span class="s1">&#39;</span>
                                <span class="sa">f</span><span class="s1">&#39; hits were marked as tentative from cluster </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1"> &#39;</span>
                                <span class="sa">f</span><span class="s1">&#39;for </span><span class="si">{</span><span class="n">cpname</span><span class="si">}</span><span class="s1"> as a result of refinement by mass confidence.&#39;</span><span class="p">)</span>
            
            <span class="c1">#Put the final refined cluster into the refined_clusters list</span>
            <span class="n">refined_clusters</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ref3_cluster</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        

        <span class="c1">#If there is more than one cluster, compare their mean mass confidences</span>
        <span class="c1">#Remove any where that mean is less than the maximum mean * massConf_threshold</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">refined_clusters</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">after_ref</span> <span class="o">=</span> <span class="n">selectClusterByMassConf</span><span class="p">(</span><span class="n">refined_clusters</span><span class="p">)</span>
            <span class="n">refined_clusters</span> <span class="o">=</span> <span class="n">after_ref</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">output</span><span class="p">[</span><span class="s2">&quot;discarded_by_cluster&quot;</span><span class="p">]</span> <span class="o">+=</span> <span class="n">after_ref</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">comment_text</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">after_ref</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="si">}</span><span class="s1"> clusters were discarded after refinement&#39;</span>
                                 <span class="s1">&#39; by mass confidence. &#39;</span><span class="p">)</span>
            
        <span class="c1">#If there is still more than one cluster, compare their size.</span>
        <span class="c1">#Take only those which are larger than (max_size * cluster_size_threshold)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">refined_clusters</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">after_ref</span> <span class="o">=</span> <span class="n">selectClusterBySize</span><span class="p">(</span><span class="n">refined_clusters</span><span class="p">)</span>
            <span class="n">refined_clusters</span> <span class="o">=</span> <span class="n">after_ref</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">output</span><span class="p">[</span><span class="s2">&quot;discarded_by_cluster&quot;</span><span class="p">]</span> <span class="o">+=</span> <span class="n">after_ref</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">comment_text</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">after_ref</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="si">}</span><span class="s1"> clusters were discarded after refinement&#39;</span>
                                 <span class="s1">&#39; by size comparison. &#39;</span><span class="p">)</span>
        
        <span class="c1">#If there is still more than one cluster, the peak used in the heatmap</span>
        <span class="c1">#will be selected based only on peakarea. Inform the user that </span>
        <span class="c1">#manual selection is required. </span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">refined_clusters</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">comment_text</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;&lt;strong&gt;High Priority: More than one cluster was found for </span><span class="si">{</span><span class="n">cpname</span><span class="si">}</span><span class="s1">. &#39;</span> 
                                          <span class="s1">&#39;User MUST perform their own analysis.&lt;/strong&gt;&#39;</span><span class="p">)</span>

        
        <span class="c1">#Convert the format of the data so that it is indexed</span>
        <span class="c1">#by the well it&#39;s in        </span>
        <span class="n">cluster_by_well</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">cluster</span> <span class="ow">in</span> <span class="n">refined_clusters</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">peak</span> <span class="ow">in</span> <span class="n">cluster</span><span class="p">[</span><span class="s2">&quot;green&quot;</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">peak</span><span class="p">[</span><span class="s2">&quot;well&quot;</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cluster_by_well</span><span class="p">:</span>
                    <span class="n">cluster_by_well</span><span class="p">[</span><span class="n">peak</span><span class="p">[</span><span class="s2">&quot;well&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{</span>
                            <span class="s2">&quot;green&quot;</span><span class="p">:</span> <span class="p">[],</span>
                            <span class="s2">&quot;orange&quot;</span><span class="p">:</span> <span class="p">[],</span>
                            <span class="s2">&quot;discarded&quot;</span><span class="p">:</span> <span class="p">[],</span>
                            <span class="p">}</span>
            
                <span class="n">cluster_by_well</span><span class="p">[</span><span class="n">peak</span><span class="p">[</span><span class="s2">&quot;well&quot;</span><span class="p">]][</span><span class="s2">&quot;green&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">peak</span><span class="p">)</span>
                
            <span class="k">for</span> <span class="n">peak</span> <span class="ow">in</span> <span class="n">cluster</span><span class="p">[</span><span class="s2">&quot;orange&quot;</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">peak</span><span class="p">[</span><span class="s2">&quot;well&quot;</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cluster_by_well</span><span class="p">:</span>
                    <span class="n">cluster_by_well</span><span class="p">[</span><span class="n">peak</span><span class="p">[</span><span class="s2">&quot;well&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{</span>
                            <span class="s2">&quot;green&quot;</span><span class="p">:</span> <span class="p">[],</span>
                            <span class="s2">&quot;orange&quot;</span><span class="p">:</span> <span class="p">[],</span>
                            <span class="s2">&quot;discarded&quot;</span><span class="p">:</span> <span class="p">[],</span>
                            <span class="p">}</span>
            
                <span class="n">cluster_by_well</span><span class="p">[</span><span class="n">peak</span><span class="p">[</span><span class="s2">&quot;well&quot;</span><span class="p">]][</span><span class="s2">&quot;orange&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">peak</span><span class="p">)</span>
            
            <span class="k">for</span> <span class="n">peak</span> <span class="ow">in</span> <span class="n">cluster</span><span class="p">[</span><span class="s2">&quot;discarded&quot;</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">peak</span><span class="p">[</span><span class="s2">&quot;well&quot;</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cluster_by_well</span><span class="p">:</span>
                    <span class="n">cluster_by_well</span><span class="p">[</span><span class="n">peak</span><span class="p">[</span><span class="s2">&quot;well&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{</span>
                            <span class="s2">&quot;green&quot;</span><span class="p">:</span> <span class="p">[],</span>
                            <span class="s2">&quot;orange&quot;</span><span class="p">:</span> <span class="p">[],</span>
                            <span class="s2">&quot;discarded&quot;</span><span class="p">:</span> <span class="p">[],</span>
                            <span class="p">}</span>
            
                <span class="n">cluster_by_well</span><span class="p">[</span><span class="n">peak</span><span class="p">[</span><span class="s2">&quot;well&quot;</span><span class="p">]][</span><span class="s2">&quot;discarded&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">peak</span><span class="p">)</span>
        
        <span class="c1">#For each well, select which peaks are green and </span>
        <span class="c1">#which should be discarded. </span>
        <span class="c1">#This is done using the results of the above prioritisation</span>
        <span class="c1">#Peaks under &quot;green&quot; are chosen first. If none are available for that</span>
        <span class="c1">#well, a orange peak is used instead. It is important to note that</span>
        <span class="c1">#even a orange peak must conform to tight retentionTime criteria.</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">well</span> <span class="ow">in</span> <span class="n">cluster_by_well</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">output</span><span class="p">[</span><span class="s2">&quot;discarded&quot;</span><span class="p">]</span> <span class="o">+=</span> <span class="n">well</span><span class="p">[</span><span class="s2">&quot;discarded&quot;</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">well</span><span class="p">[</span><span class="s2">&quot;green&quot;</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">well</span><span class="p">[</span><span class="s2">&quot;green&quot;</span><span class="p">])</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">output</span><span class="p">[</span><span class="s2">&quot;green&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">well</span><span class="p">[</span><span class="s2">&quot;green&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">id_max</span> <span class="o">=</span> <span class="n">options</span><span class="o">.</span><span class="n">mass_or_area</span>
                    
                    <span class="n">max_val</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">peak</span><span class="p">[</span><span class="n">id_max</span><span class="p">]</span> <span class="k">for</span> <span class="n">peak</span> <span class="ow">in</span> <span class="n">well</span><span class="p">[</span><span class="s2">&quot;green&quot;</span><span class="p">])</span>
                    <span class="n">peak_added</span> <span class="o">=</span> <span class="kc">False</span>
                    
                    <span class="c1">#Sort the peaks by their peak area, so that if two</span>
                    <span class="c1">#peaks have the same mass_conf when options.mass_or_area is</span>
                    <span class="c1">#equal to &quot;mass_conf&quot;, the largest peak is selected in preference. </span>

                    <span class="k">for</span> <span class="n">peak</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">well</span><span class="p">[</span><span class="s2">&quot;green&quot;</span><span class="p">],</span> <span class="n">key</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="s2">&quot;area&quot;</span><span class="p">],</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">peak_added</span> <span class="o">==</span> <span class="kc">False</span> <span class="ow">and</span> <span class="n">peak</span><span class="p">[</span><span class="n">id_max</span><span class="p">]</span> <span class="o">==</span> <span class="n">max_val</span><span class="p">:</span>
                            <span class="n">output</span><span class="p">[</span><span class="s2">&quot;green&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">peak</span><span class="p">)</span>
                            <span class="n">comment_text</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Largest </span><span class="si">{</span><span class="n">id_max</span><span class="si">}</span><span class="s1"> selected in preference to others available for well &#39;</span>
                                                <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">getUserReadableWell</span><span class="p">(</span><span class="n">peak</span><span class="p">[</span><span class="s2">&quot;well&quot;</span><span class="p">])</span><span class="si">}</span><span class="s1">.&#39;</span><span class="p">)</span>
                            <span class="n">peak_added</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">output</span><span class="p">[</span><span class="s2">&quot;discarded&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">peak</span><span class="p">)</span>
                            <span class="n">comment_text</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;The peak at </span><span class="si">{</span><span class="n">peak</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">]</span><span class="si">}</span><span class="s1"> in well </span><span class="si">{</span><span class="n">getUserReadableWell</span><span class="p">(</span><span class="n">peak</span><span class="p">[</span><span class="s2">&quot;well&quot;</span><span class="p">])</span><span class="si">}</span><span class="s1"> &#39;</span>
                                                      <span class="sa">f</span><span class="s1">&#39;was discarded as it had a smaller </span><span class="si">{</span><span class="n">id_max</span><span class="si">}</span><span class="s1"> than an &#39;</span>
                                                      <span class="sa">f</span><span class="s1">&#39;equally likely alternative.&#39;</span><span class="p">)</span>
                
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">well</span><span class="p">[</span><span class="s2">&quot;orange&quot;</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">output</span><span class="p">[</span><span class="s2">&quot;discarded&quot;</span><span class="p">]</span> <span class="o">+=</span> <span class="n">well</span><span class="p">[</span><span class="s2">&quot;orange&quot;</span><span class="p">]</span>
                    <span class="k">for</span> <span class="n">peak</span> <span class="ow">in</span> <span class="n">well</span><span class="p">[</span><span class="s2">&quot;orange&quot;</span><span class="p">]:</span>
                        <span class="n">comment_text</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;The peak at </span><span class="si">{</span><span class="n">peak</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">]</span><span class="si">}</span><span class="s1"> in well &#39;</span>
                                    <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">getUserReadableWell</span><span class="p">(</span><span class="n">peak</span><span class="p">[</span><span class="s2">&quot;well&quot;</span><span class="p">])</span><span class="si">}</span><span class="s1"> for </span><span class="si">{</span><span class="n">cpname</span><span class="si">}</span><span class="s1"> was discarded &#39;</span>
                                    <span class="sa">f</span><span class="s1">&#39;because a better match was found.&#39;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">well</span><span class="p">[</span><span class="s2">&quot;orange&quot;</span><span class="p">])</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">peak</span> <span class="o">=</span> <span class="n">well</span><span class="p">[</span><span class="s2">&quot;orange&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">output</span><span class="p">[</span><span class="s2">&quot;green&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">well</span><span class="p">[</span><span class="s2">&quot;orange&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">comment_text</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;&lt;strong&gt;The tentative peak at </span><span class="si">{</span><span class="n">peak</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">]</span><span class="si">}</span><span class="s1"> in well </span><span class="si">{</span><span class="n">getUserReadableWell</span><span class="p">(</span><span class="n">peak</span><span class="p">[</span><span class="s2">&quot;well&quot;</span><span class="p">])</span><span class="si">}</span><span class="s1"> was &#39;</span>
                                          <span class="sa">f</span><span class="s1">&#39;used as there was no better option. User should check this well.&lt;/strong&gt;&#39;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">well</span><span class="p">[</span><span class="s2">&quot;orange&quot;</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">id_max</span> <span class="o">=</span> <span class="n">options</span><span class="o">.</span><span class="n">mass_or_area</span>
                <span class="n">max_val</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">peak</span><span class="p">[</span><span class="n">id_max</span><span class="p">]</span> <span class="k">for</span> <span class="n">peak</span> <span class="ow">in</span> <span class="n">well</span><span class="p">[</span><span class="s2">&quot;orange&quot;</span><span class="p">])</span>
                <span class="n">peak_added</span> <span class="o">=</span> <span class="kc">False</span>

                <span class="c1">#Sort the peaks by their peak area, so that if two</span>
                <span class="c1">#peaks have the same mass_conf when options.mass_or_area is</span>
                <span class="c1">#equal to &quot;mass_conf&quot;, the largest peak is selected in preference. </span>

                <span class="k">for</span> <span class="n">peak</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">well</span><span class="p">[</span><span class="s2">&quot;orange&quot;</span><span class="p">],</span> <span class="n">key</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="s2">&quot;area&quot;</span><span class="p">],</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">peak_added</span> <span class="o">==</span> <span class="kc">False</span> <span class="ow">and</span> <span class="n">peak</span><span class="p">[</span><span class="n">id_max</span><span class="p">]</span> <span class="o">==</span> <span class="n">max_val</span><span class="p">:</span>
                        <span class="n">output</span><span class="p">[</span><span class="s2">&quot;green&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">peak</span><span class="p">)</span>
                        <span class="n">comment_text</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Largest </span><span class="si">{</span><span class="n">id_max</span><span class="si">}</span><span class="s1"> selected in preference to other tentative hits available for well &#39;</span>
                                            <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">getUserReadableWell</span><span class="p">(</span><span class="n">peak</span><span class="p">[</span><span class="s2">&quot;well&quot;</span><span class="p">])</span><span class="si">}</span><span class="s1">.&#39;</span><span class="p">)</span>
                        <span class="n">peak_added</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">output</span><span class="p">[</span><span class="s2">&quot;discarded&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">peak</span><span class="p">)</span>
                        <span class="n">comment_text</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;&lt;strong&gt;The tentative peak at </span><span class="si">{</span><span class="n">peak</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">]</span><span class="si">}</span><span class="s1"> in well </span><span class="si">{</span><span class="n">getUserReadableWell</span><span class="p">(</span><span class="n">peak</span><span class="p">[</span><span class="s2">&quot;well&quot;</span><span class="p">])</span><span class="si">}</span><span class="s1"> &#39;</span>
                                                      <span class="sa">f</span><span class="s1">&#39;was discarded as it had a smaller </span><span class="si">{</span><span class="n">id_max</span><span class="si">}</span><span class="s1"> than an &#39;</span>
                                                      <span class="sa">f</span><span class="s1">&#39;equally likely alternative.&lt;/strong&gt;&#39;</span><span class="p">)</span>
        
        <span class="n">mean_time</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">i</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">output</span><span class="p">[</span><span class="s2">&quot;green&quot;</span><span class="p">]])</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">output</span><span class="p">[</span><span class="s2">&quot;green&quot;</span><span class="p">])</span>
                
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">peakList</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">options</span><span class="o">.</span><span class="n">validate</span> <span class="o">==</span> <span class="s2">&quot;True&quot;</span><span class="p">:</span>
            <span class="n">comment_text</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;Validation was not performed as requested by the user.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">comment_text</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Validation was not performed for </span><span class="si">{</span><span class="n">cpname</span><span class="si">}</span><span class="s1"> as &#39;</span>
                                <span class="s1">&#39;there were insufficient hits.&#39;</span><span class="p">)</span>
        <span class="c1">#organise the peaks by the well they occupy</span>
        <span class="n">cluster_by_well</span> <span class="o">=</span> <span class="p">{}</span>
        
        <span class="k">for</span> <span class="n">cluster</span> <span class="ow">in</span> <span class="n">clusters</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">peak</span> <span class="ow">in</span> <span class="n">cluster</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">peak</span><span class="p">[</span><span class="s2">&quot;well&quot;</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cluster_by_well</span><span class="p">:</span>
                    <span class="n">cluster_by_well</span><span class="p">[</span><span class="n">peak</span><span class="p">[</span><span class="s2">&quot;well&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">cluster_by_well</span><span class="p">[</span><span class="n">peak</span><span class="p">[</span><span class="s2">&quot;well&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">peak</span><span class="p">)</span>
     
        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Peaks were chosen for </span><span class="si">{</span><span class="n">cpname</span><span class="si">}</span><span class="s1"> by </span><span class="si">{</span><span class="n">options</span><span class="o">.</span><span class="n">mass_or_area</span><span class="si">}</span><span class="s1">.&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">well</span> <span class="ow">in</span> <span class="n">cluster_by_well</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">well</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">id_max</span> <span class="o">=</span> <span class="n">options</span><span class="o">.</span><span class="n">mass_or_area</span>
                <span class="n">max_val</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">well</span><span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="n">id_max</span><span class="p">])[</span><span class="n">id_max</span><span class="p">]</span>

                <span class="c1">#Sort the peaks by their peak area, so that if two</span>
                <span class="c1">#peaks have the same mass_conf when options.mass_or_area is</span>
                <span class="c1">#equal to &quot;mass_conf&quot;, the largest peak is selected in preference. </span>
                <span class="n">peak_added</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">for</span> <span class="n">peak</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">well</span><span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="s2">&quot;area&quot;</span><span class="p">],</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
                    
                    <span class="k">if</span> <span class="n">peak_added</span> <span class="o">==</span> <span class="kc">False</span> <span class="ow">and</span> <span class="n">peak</span><span class="p">[</span><span class="n">id_max</span><span class="p">]</span> <span class="o">==</span> <span class="n">max_val</span><span class="p">:</span>
                        <span class="n">output</span><span class="p">[</span><span class="s2">&quot;green&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">peak</span><span class="p">)</span>
                        <span class="n">comment_text</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;The hit at </span><span class="si">{</span><span class="n">peak</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">]</span><span class="si">}</span><span class="s1"> for </span><span class="si">{</span><span class="n">cpname</span><span class="si">}</span><span class="s1"> in well&#39;</span>
                                            <span class="sa">f</span><span class="s1">&#39; </span><span class="si">{</span><span class="n">getUserReadableWell</span><span class="p">(</span><span class="n">peak</span><span class="p">[</span><span class="s2">&quot;well&quot;</span><span class="p">])</span><span class="si">}</span><span class="s1"> was selected as it had the largest&#39;</span>
                                            <span class="sa">f</span><span class="s1">&#39; </span><span class="si">{</span><span class="n">id_max</span><span class="si">}</span><span class="s1">.&#39;</span><span class="p">)</span>
                        <span class="n">peak_added</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">output</span><span class="p">[</span><span class="s2">&quot;discarded&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">peak</span><span class="p">)</span>
                        <span class="n">comment_text</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;The hit at </span><span class="si">{</span><span class="n">peak</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">]</span><span class="si">}</span><span class="s1"> for </span><span class="si">{</span><span class="n">cpname</span><span class="si">}</span><span class="s1"> in well&#39;</span>
                                            <span class="sa">f</span><span class="s1">&#39; </span><span class="si">{</span><span class="n">getUserReadableWell</span><span class="p">(</span><span class="n">peak</span><span class="p">[</span><span class="s2">&quot;well&quot;</span><span class="p">])</span><span class="si">}</span><span class="s1"> was discarded as&#39;</span>
                                            <span class="sa">f</span><span class="s1">&#39; it did not have the largest </span><span class="si">{</span><span class="n">id_max</span><span class="si">}</span><span class="s1"> of all hits found.&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">output</span><span class="p">[</span><span class="s2">&quot;green&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">well</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>


        <span class="n">mean_time</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">i</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">output</span><span class="p">[</span><span class="s2">&quot;green&quot;</span><span class="p">]])</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">output</span><span class="p">[</span><span class="s2">&quot;green&quot;</span><span class="p">])</span>
           
    <span class="k">return</span> <span class="p">[</span><span class="n">output</span><span class="p">,</span> <span class="n">comment_text</span><span class="p">,</span> <span class="n">cluster_bands</span><span class="p">]</span></div>
        
<div class="viewcode-block" id="removeDupAssigns"><a class="viewcode-back" href="../pyparse_det.html#PyParse.removeDupAssigns">[docs]</a><span class="k">def</span> <span class="nf">removeDupAssigns</span><span class="p">(</span><span class="n">compoundDF</span><span class="p">,</span> <span class="n">internalSTD</span><span class="p">,</span> <span class="n">SMs</span><span class="p">,</span> <span class="n">products</span><span class="p">,</span> <span class="n">by_products</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Checks each compound to ensure that no peak has been assigned </span>
<span class="sd">    to two different compounds. If this has happened, the internalSTD</span>
<span class="sd">    (if present) takes first priority, limiting reactant is second priority,</span>
<span class="sd">    product third priority and finally a by-product is lowest priority.</span>

<span class="sd">    :param compoundDF: Pandas dataframe</span>
<span class="sd">    :param internalSTD: A string representing the name of the internal standard</span>
<span class="sd">    :param SMs: A list of starting material names</span>
<span class="sd">    :param products: A list of product names</span>
<span class="sd">    :param by_products: A list of by_product names</span>
<span class="sd">    </span>
<span class="sd">    :return: compoundDF as Pandas dataframe</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">isSamePeak</span><span class="p">(</span><span class="n">hit1</span><span class="p">,</span> <span class="n">row</span><span class="p">):</span>
        <span class="n">overlap</span> <span class="o">=</span> <span class="kc">False</span>
        
        <span class="k">for</span> <span class="n">peak</span> <span class="ow">in</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;hits&quot;</span><span class="p">][</span><span class="s2">&quot;green&quot;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">hit1</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">peak</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">]</span> <span class="ow">and</span> <span class="n">hit1</span><span class="p">[</span><span class="s2">&quot;well&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">peak</span><span class="p">[</span><span class="s2">&quot;well&quot;</span><span class="p">]:</span>
                <span class="n">overlap</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="n">overlap</span>
    
    <span class="n">items_to_remove</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">compoundDF</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>

        <span class="k">for</span> <span class="n">bindex</span><span class="p">,</span> <span class="n">brow</span> <span class="ow">in</span> <span class="n">compoundDF</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
            
            <span class="k">if</span> <span class="n">index</span> <span class="o">!=</span> <span class="n">bindex</span><span class="p">:</span>
                <span class="n">overlap</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">brow</span><span class="p">[</span><span class="s2">&quot;hits&quot;</span><span class="p">][</span><span class="s2">&quot;green&quot;</span><span class="p">])</span> <span class="k">if</span> <span class="n">isSamePeak</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">row</span><span class="p">)]</span>
                <span class="c1">#If the name is the internalSTD, we always remove the overlap from the brow</span>
                <span class="k">if</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">internalSTD</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">overlap</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">bindex</span> <span class="ow">in</span> <span class="n">items_to_remove</span><span class="p">:</span>
                            <span class="n">items_to_remove</span><span class="p">[</span><span class="n">bindex</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">items_to_remove</span><span class="p">[</span><span class="n">bindex</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="c1">#Peaks should be assigned to the starting material if there is a conflict,</span>
                <span class="c1">#unless that peak belongs to the internal standard      </span>
                <span class="k">elif</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span> <span class="ow">in</span> <span class="n">SMs</span> <span class="ow">and</span> <span class="n">brow</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span> <span class="o">!=</span> <span class="n">internalSTD</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">overlap</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">bindex</span> <span class="ow">in</span> <span class="n">items_to_remove</span><span class="p">:</span>
                            <span class="n">items_to_remove</span><span class="p">[</span><span class="n">bindex</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">items_to_remove</span><span class="p">[</span><span class="n">bindex</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="p">]</span>
                
                <span class="c1">#Peaks should be assigned to the product if there is a conflict between product </span>
                <span class="c1">#and by-product, as long as both compounds are expected in the well the peak </span>
                <span class="c1">#belongs to.</span>
                <span class="k">elif</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span> <span class="ow">in</span> <span class="n">products</span> <span class="ow">and</span> <span class="n">brow</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span> <span class="ow">in</span> <span class="n">by_products</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">overlap</span><span class="p">:</span>

                        <span class="k">if</span> <span class="n">bindex</span> <span class="ow">in</span> <span class="n">items_to_remove</span><span class="p">:</span>
                            <span class="n">items_to_remove</span><span class="p">[</span><span class="n">bindex</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">items_to_remove</span><span class="p">[</span><span class="n">bindex</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="p">]</span>
    
    <span class="c1">#If a peak is scheduled for removal, the program should check to see if </span>
    <span class="c1">#a previously discarded peak in the same cluster and well</span>
    <span class="c1">#should be promoted to replace it. </span>
    
    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">to_remove</span> <span class="ow">in</span> <span class="n">items_to_remove</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        
        <span class="n">hit_copy</span> <span class="o">=</span> <span class="n">compoundDF</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">index</span><span class="p">,</span> <span class="s2">&quot;hits&quot;</span><span class="p">]</span>

        <span class="n">new_green</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">new_discarded</span> <span class="o">=</span> <span class="n">hit_copy</span><span class="p">[</span><span class="s2">&quot;discarded&quot;</span><span class="p">][:]</span>
        <span class="n">new_dbc</span> <span class="o">=</span> <span class="n">hit_copy</span><span class="p">[</span><span class="s2">&quot;discarded_by_cluster&quot;</span><span class="p">][:]</span>
        <span class="n">new_comments</span> <span class="o">=</span> <span class="n">compoundDF</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">index</span><span class="p">,</span> <span class="s2">&quot;comments&quot;</span><span class="p">][:]</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">hit_copy</span><span class="p">[</span><span class="s2">&quot;green&quot;</span><span class="p">]):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">to_remove</span><span class="p">:</span>
                <span class="n">new_green</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
            
                <span class="n">new_discarded</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
                <span class="n">new_comments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;&lt;strong&gt;The peak in well </span><span class="si">{</span><span class="n">getUserReadableWell</span><span class="p">(</span><span class="n">j</span><span class="p">[</span><span class="s2">&quot;well&quot;</span><span class="p">])</span><span class="si">}</span><span class="s1"> at </span><span class="si">{</span><span class="n">j</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">]</span><span class="si">}</span><span class="s1"> minutes was deselected &#39;</span>
                                    <span class="s1">&#39;because it was already assigned to the SM, internalSTD or by-product.&lt;/strong&gt;&#39;</span><span class="p">)</span>
                
                <span class="c1">#find a replacement peak if possible to do so from the same cluster and same well</span>
                <span class="n">cluster</span> <span class="o">=</span> <span class="n">j</span><span class="p">[</span><span class="s2">&quot;cluster&quot;</span><span class="p">]</span>
                <span class="n">well</span> <span class="o">=</span> <span class="n">j</span><span class="p">[</span><span class="s2">&quot;well&quot;</span><span class="p">]</span>
                <span class="n">poss_replace</span> <span class="o">=</span> <span class="p">[</span><span class="n">peak</span> <span class="k">for</span> <span class="n">peak</span> <span class="ow">in</span> <span class="n">hit_copy</span><span class="p">[</span><span class="s2">&quot;discarded&quot;</span><span class="p">]</span> <span class="k">if</span> <span class="n">peak</span><span class="p">[</span><span class="s2">&quot;cluster&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">cluster</span> <span class="ow">and</span> <span class="n">peak</span><span class="p">[</span><span class="s2">&quot;well&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">well</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">poss_replace</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">id_max</span> <span class="o">=</span> <span class="n">options</span><span class="o">.</span><span class="n">mass_or_area</span>
                    <span class="n">best_peak</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">poss_replace</span><span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="n">id_max</span><span class="p">])</span>
                    <span class="n">new_green</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">best_peak</span><span class="p">)</span>
                    <span class="n">new_comments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;&lt;strong&gt;The peak in well </span><span class="si">{</span><span class="n">getUserReadableWell</span><span class="p">(</span><span class="n">well</span><span class="p">)</span><span class="si">}</span><span class="s1"> at </span><span class="si">{</span><span class="n">best_peak</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">]</span><span class="si">}</span><span class="s1"> minutes was promoted to replace the &#39;</span>
                                        <span class="sa">f</span><span class="s1">&#39;peak that was deselected, and was selected for promotion as it had the largest &#39;</span>
                                        <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">id_max</span><span class="si">}</span><span class="s1">.&lt;/strong&gt;&#39;</span><span class="p">)</span>                    

                
        <span class="n">compoundDF</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">index</span><span class="p">,</span> <span class="s2">&quot;hits&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;green&quot;</span><span class="p">:</span> <span class="n">new_green</span><span class="p">,</span>
            <span class="s2">&quot;discarded&quot;</span><span class="p">:</span> <span class="n">new_discarded</span><span class="p">,</span>
            <span class="s2">&quot;discarded_by_cluster&quot;</span><span class="p">:</span> <span class="n">new_dbc</span>
        <span class="p">}</span>
        <span class="n">compoundDF</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">index</span><span class="p">,</span> <span class="s2">&quot;comments&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_comments</span> 
    <span class="k">return</span> <span class="n">compoundDF</span></div>

<div class="viewcode-block" id="findImpurities"><a class="viewcode-back" href="../pyparse_det.html#PyParse.findImpurities">[docs]</a><span class="k">def</span> <span class="nf">findImpurities</span><span class="p">(</span><span class="n">dataTable</span><span class="p">,</span> <span class="n">compoundDF</span><span class="p">,</span> <span class="n">save_dir</span><span class="p">,</span> <span class="n">chroma</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The goal of this function is to find impurities that the program wasn&#39;t explicitly</span>
<span class="sd">    asked to find. It will do this by searching for commonly appearing peaks, that have a </span>
<span class="sd">    clear ionisation pattern, that haven&#39;t already been assigned. </span>

<span class="sd">    :param dataTable: dictionary of all peaks, indexed by well</span>
<span class="sd">    :param compoundDF: pandas dataframe for all compounds</span>
<span class="sd">    :param save_dir: string for output directory</span>
<span class="sd">    :param chroma: a dictionary containing chromatograms, indexed by well</span>

<span class="sd">    :return: Chromatograms for each impurity, additional rows in the compoundDF,</span>
<span class="sd">             and hit validation graph plotted containing all impurity hits.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">impurities</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1">#Define sub-function to find common ions for a cluster of peaks</span>
    <span class="k">def</span> <span class="nf">findCommonIons</span><span class="p">(</span><span class="n">cluster</span><span class="p">):</span>
        <span class="n">ions_plus</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">ions_minus</span> <span class="o">=</span> <span class="p">{}</span>
       
        <span class="k">for</span> <span class="n">peak</span> <span class="ow">in</span> <span class="n">cluster</span><span class="p">:</span>

            <span class="n">sorted_MS_plus</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">peak</span><span class="p">[</span><span class="s2">&quot;MS+&quot;</span><span class="p">],</span> <span class="n">key</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">sorted_MS_minus</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">peak</span><span class="p">[</span><span class="s2">&quot;MS-&quot;</span><span class="p">],</span> <span class="n">key</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

            
            <span class="k">for</span> <span class="n">ms</span> <span class="ow">in</span> <span class="n">sorted_MS_plus</span><span class="p">:</span>
                <span class="n">latest_keys</span> <span class="o">=</span> <span class="n">ions_plus</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
                <span class="n">overlap</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">latest_keys</span> <span class="k">if</span> <span class="n">math</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">ms</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">i</span><span class="p">,</span> <span class="n">abs_tol</span> <span class="o">=</span> <span class="n">options</span><span class="o">.</span><span class="n">mass_abs_tol</span><span class="p">)]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">overlap</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">ions_plus</span><span class="p">[</span><span class="n">overlap</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ms</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">ions_plus</span><span class="p">[</span><span class="n">ms</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[</span><span class="n">ms</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>

            <span class="k">for</span> <span class="n">ms</span> <span class="ow">in</span> <span class="n">sorted_MS_minus</span><span class="p">:</span>
                <span class="n">latest_keys</span> <span class="o">=</span> <span class="n">ions_minus</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
                <span class="n">overlap</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">latest_keys</span> <span class="k">if</span> <span class="n">math</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">ms</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">i</span><span class="p">,</span> <span class="n">abs_tol</span> <span class="o">=</span> <span class="n">options</span><span class="o">.</span><span class="n">mass_abs_tol</span><span class="p">)]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">overlap</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">ions_minus</span><span class="p">[</span><span class="n">overlap</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ms</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">ions_minus</span><span class="p">[</span><span class="n">ms</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[</span><span class="n">ms</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>

        <span class="c1">#Filter the ions down to those which appear in at least 80% of the peaks</span>
        <span class="n">filtered_plus</span> <span class="o">=</span> <span class="p">[[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">ions_plus</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">cluster</span><span class="p">)</span><span class="o">*</span><span class="mf">0.8</span><span class="p">]</span>
        <span class="n">filtered_minus</span> <span class="o">=</span> <span class="p">[[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">ions_minus</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">cluster</span><span class="p">)</span><span class="o">*</span><span class="mf">0.8</span><span class="p">]</span>

        <span class="c1">#Filter to just the top 5 most commonly observed peaks, to guarantee a maximum</span>
        <span class="c1">#number of 5 mass ions reported. </span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">filtered_plus</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="p">:</span>
            <span class="n">filtered_plus</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">filtered_plus</span><span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">reverse</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)[</span><span class="mi">0</span><span class="p">:</span><span class="mi">5</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">filtered_minus</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="p">:</span>
            <span class="n">filtered_minus</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">filtered_minus</span><span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">reverse</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)[</span><span class="mi">0</span><span class="p">:</span><span class="mi">5</span><span class="p">]</span>

        <span class="n">return_plus</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">filtered_plus</span><span class="p">]</span>
        <span class="n">return_minus</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">filtered_minus</span><span class="p">]</span>

        <span class="k">return</span> <span class="p">[</span><span class="n">return_plus</span><span class="p">,</span> <span class="n">return_minus</span><span class="p">]</span>

    <span class="c1">#Define function to get a list of wells from a cluster, </span>
    <span class="c1">#without any duplicates</span>
    <span class="k">def</span> <span class="nf">getWells</span><span class="p">(</span><span class="n">cluster</span><span class="p">):</span>
        <span class="n">wells</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">peak</span> <span class="ow">in</span> <span class="n">cluster</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">peak</span><span class="p">[</span><span class="s2">&quot;well&quot;</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">wells</span><span class="p">:</span> 
                <span class="n">wells</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">peak</span><span class="p">[</span><span class="s2">&quot;well&quot;</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">wells</span>
    
    <span class="c1">#Index all peaks in plate by their well and retention time</span>
    <span class="n">peakList</span> <span class="o">=</span> <span class="p">{}</span>
    
    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">well</span> <span class="ow">in</span> <span class="n">dataTable</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">peakList</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">peak</span> <span class="ow">in</span> <span class="n">well</span><span class="p">:</span>
            <span class="n">peakList</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="n">peak</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">peak</span>
    
    <span class="c1">#Remove any peaks which have already been assigned to a compound</span>
    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">compoundDF</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
        <span class="k">for</span> <span class="n">hit</span> <span class="ow">in</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;hits&quot;</span><span class="p">][</span><span class="s2">&quot;green&quot;</span><span class="p">]:</span>
            <span class="k">del</span> <span class="n">peakList</span><span class="p">[</span><span class="n">hit</span><span class="p">[</span><span class="s2">&quot;well&quot;</span><span class="p">]][</span><span class="n">hit</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">]]</span>

    <span class="c1">#Convert the dictionary to a easier-to-handle list</span>
    <span class="c1">#now that the above filtering has taken place. </span>
    <span class="n">all_peaks</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">wellID</span><span class="p">,</span> <span class="n">well</span> <span class="ow">in</span> <span class="n">peakList</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">for</span> <span class="n">time</span><span class="p">,</span> <span class="n">peak</span> <span class="ow">in</span> <span class="n">well</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">all_peaks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">peak</span><span class="p">)</span>

    <span class="c1">#Sort the peaks by their retention time</span>
    <span class="n">all_peaks</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">])</span>
    
    <span class="c1">#Organise the peaks into clusters</span>
    <span class="n">clusters</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">all_peaks</span><span class="p">)):</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">clusters</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">clusters</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">all_peaks</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">clusterFound</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">for</span> <span class="n">cluster</span> <span class="ow">in</span> <span class="n">clusters</span><span class="p">:</span>
                <span class="n">mean_rt</span> <span class="o">=</span> <span class="n">mean</span><span class="p">([</span><span class="n">i</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">cluster</span><span class="p">])</span>
                
                <span class="k">if</span> <span class="n">math</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">mean_rt</span><span class="p">,</span> <span class="n">all_peaks</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s2">&quot;time&quot;</span><span class="p">],</span> <span class="n">abs_tol</span><span class="o">=</span><span class="n">options</span><span class="o">.</span><span class="n">time_abs_tol</span><span class="p">):</span>
                    <span class="n">cluster</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">all_peaks</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                    <span class="n">clusterFound</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">break</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">clusterFound</span><span class="p">:</span>
                <span class="n">clusters</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">all_peaks</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>

    <span class="c1">#Filter to just those clusters which contain a sufficient number of impurity-containing wells.</span>
    
    <span class="n">clusters</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">getWells</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="o">&gt;</span> <span class="n">options</span><span class="o">.</span><span class="n">min_no_of_wells</span><span class="p">,</span> <span class="n">clusters</span><span class="p">))</span>

    <span class="c1">#Format the data in each cluster into a form suitable for </span>
    <span class="c1">#the compoundDF.</span>
    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">cluster</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">clusters</span><span class="p">):</span>
        <span class="n">hits</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;green&quot;</span><span class="p">:</span> <span class="p">[],</span>
            <span class="s2">&quot;discarded&quot;</span><span class="p">:</span> <span class="p">[],</span>
            <span class="s2">&quot;discarded_by_cluster&quot;</span><span class="p">:</span> <span class="p">[[]]</span>
        <span class="p">}</span>
        <span class="k">for</span> <span class="n">peak</span> <span class="ow">in</span> <span class="n">cluster</span><span class="p">:</span>
            <span class="n">goingin</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;area&quot;</span><span class="p">:</span> <span class="n">peak</span><span class="p">[</span><span class="s2">&quot;area&quot;</span><span class="p">],</span>
                <span class="s2">&quot;areaAbs&quot;</span><span class="p">:</span> <span class="n">peak</span><span class="p">[</span><span class="s2">&quot;areaAbs&quot;</span><span class="p">],</span>
                <span class="s2">&quot;UV&quot;</span><span class="p">:</span> <span class="n">peak</span><span class="p">[</span><span class="s2">&quot;UV&quot;</span><span class="p">],</span>
                <span class="s2">&quot;pStart&quot;</span><span class="p">:</span> <span class="n">peak</span><span class="p">[</span><span class="s2">&quot;pStart&quot;</span><span class="p">],</span>
                <span class="s2">&quot;pEnd&quot;</span><span class="p">:</span> <span class="n">peak</span><span class="p">[</span><span class="s2">&quot;pEnd&quot;</span><span class="p">],</span>
                <span class="s2">&quot;time&quot;</span><span class="p">:</span> <span class="n">peak</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">],</span>
                <span class="s2">&quot;cluster&quot;</span><span class="p">:</span> <span class="n">index</span><span class="p">,</span>
                <span class="s2">&quot;well&quot;</span><span class="p">:</span> <span class="n">peak</span><span class="p">[</span><span class="s2">&quot;well&quot;</span><span class="p">],</span>
                <span class="s2">&quot;mass_conf&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
                <span class="s2">&quot;mass+&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
                <span class="s2">&quot;mass-&quot;</span><span class="p">:</span> <span class="mi">0</span>
            <span class="p">}</span>
            <span class="n">hits</span><span class="p">[</span><span class="s2">&quot;green&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">goingin</span><span class="p">)</span>
        
        <span class="n">best_purity</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">cluster</span><span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span><span class="n">x</span><span class="p">[</span><span class="s2">&quot;area&quot;</span><span class="p">])[</span><span class="s2">&quot;area&quot;</span><span class="p">]</span>
        
        <span class="n">best_well</span> <span class="o">=</span> <span class="p">[</span><span class="n">peak</span><span class="p">[</span><span class="s2">&quot;well&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">peak</span> <span class="ow">in</span> <span class="n">cluster</span> <span class="k">if</span> <span class="n">peak</span><span class="p">[</span><span class="s2">&quot;area&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">best_purity</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">mean_rt</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">mean</span><span class="p">([</span><span class="n">peak</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">peak</span> <span class="ow">in</span> <span class="n">cluster</span><span class="p">]),</span> <span class="mi">2</span><span class="p">)</span>
        <span class="p">[</span><span class="n">mass_plus</span><span class="p">,</span> <span class="n">mass_minus</span><span class="p">]</span> <span class="o">=</span> <span class="n">findCommonIons</span><span class="p">(</span><span class="n">cluster</span><span class="p">)</span>
        <span class="n">containing_wells</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">getWells</span><span class="p">(</span><span class="n">cluster</span><span class="p">))</span>
        
        <span class="n">comments</span> <span class="o">=</span> <span class="p">[]</span>
        
        <span class="c1">#Criteria to determine when a comment is added:</span>
        <span class="c1">#   -Cluster typically occurs in a particular column</span>
        <span class="c1">#   -Cluster typically occurs in a particular row</span>
        <span class="c1">#   -Cluster typically occurs for a particular compound in the platemap</span>
        <span class="c1">#   -Cluster is independant of position (i.e. whole plate) - this overrides all of the above</span>
        <span class="c1">#   -describe how many wells contained this impurity</span>

        <span class="n">comments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;This impurity was observed in </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">containing_wells</span><span class="p">)</span><span class="si">}</span><span class="s1"> wells.&#39;</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">containing_wells</span><span class="p">)</span> <span class="o">==</span> <span class="n">options</span><span class="o">.</span><span class="n">plate_row_no</span> <span class="o">*</span> <span class="n">options</span><span class="o">.</span><span class="n">plate_col_no</span><span class="p">:</span>
            <span class="n">comments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;This impurity was observed in every well of the plate.&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">containing_wells</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">options</span><span class="o">.</span><span class="n">plate_row_no</span> <span class="o">*</span> <span class="n">options</span><span class="o">.</span><span class="n">plate_col_no</span><span class="p">:</span>
            <span class="n">comments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;This impurity was observed across the majority of the plate.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1">#Build a matrix of where the compound was observed, then iterate through each row/column in turn?</span>
            <span class="n">columns</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">rows</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">well</span> <span class="ow">in</span> <span class="n">containing_wells</span><span class="p">:</span>
                <span class="n">row</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">((</span><span class="n">well</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="n">options</span><span class="o">.</span><span class="n">plate_col_no</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="n">column</span> <span class="o">=</span> <span class="p">((</span><span class="n">well</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">options</span><span class="o">.</span><span class="n">plate_col_no</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">rows</span><span class="p">:</span>
                    <span class="n">rows</span><span class="p">[</span><span class="n">row</span><span class="p">]</span> <span class="o">=</span> <span class="n">rows</span><span class="p">[</span><span class="n">row</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">rows</span><span class="p">[</span><span class="n">row</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">column</span> <span class="ow">in</span> <span class="n">columns</span><span class="p">:</span>
                    <span class="n">columns</span><span class="p">[</span><span class="n">column</span><span class="p">]</span> <span class="o">=</span> <span class="n">columns</span><span class="p">[</span><span class="n">column</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">columns</span><span class="p">[</span><span class="n">column</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

            <span class="k">for</span> <span class="n">cindex</span><span class="p">,</span> <span class="n">column</span> <span class="ow">in</span> <span class="n">columns</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">column</span> <span class="o">&gt;</span> <span class="mf">0.8</span> <span class="o">*</span> <span class="n">options</span><span class="o">.</span><span class="n">plate_row_no</span><span class="p">:</span>
                    <span class="n">comments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Impurity is frequently observed in column </span><span class="si">{</span><span class="n">cindex</span><span class="si">}</span><span class="s1">.&#39;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">rindex</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">rows</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">row</span> <span class="o">&gt;</span> <span class="mf">0.8</span> <span class="o">*</span> <span class="n">options</span><span class="o">.</span><span class="n">plate_col_no</span><span class="p">:</span>
                    <span class="n">comments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Impurity is frequently observed in row </span><span class="si">{</span><span class="nb">chr</span><span class="p">(</span><span class="nb">ord</span><span class="p">(</span><span class="s2">&quot;@&quot;</span><span class="p">)</span><span class="o">+</span><span class="p">(</span><span class="n">rindex</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="si">}</span><span class="s1">.&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">columns</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">&lt;</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">options</span><span class="o">.</span><span class="n">plate_col_no</span><span class="p">:</span>
                <span class="n">readable_cols</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">([</span><span class="nb">int</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">columns</span><span class="o">.</span><span class="n">keys</span><span class="p">()])]</span>
                <span class="n">comments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Impurity was only observed in columns </span><span class="si">{</span><span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">readable_cols</span><span class="p">)</span><span class="si">}</span><span class="s1">.&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">rows</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">&lt;</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">options</span><span class="o">.</span><span class="n">plate_row_no</span><span class="p">:</span>
                <span class="n">readable_rows</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">([</span><span class="nb">chr</span><span class="p">(</span><span class="nb">ord</span><span class="p">(</span><span class="s2">&quot;@&quot;</span><span class="p">)</span><span class="o">+</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">rows</span><span class="o">.</span><span class="n">keys</span><span class="p">()])</span>
                <span class="n">comments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Impurity was only observed in rows </span><span class="si">{</span><span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">readable_rows</span><span class="p">)</span><span class="si">}</span><span class="s1">.&#39;</span><span class="p">)</span>
            
        <span class="c1">#Column headers for the compoundDF:</span>
        <span class="c1">#[locations, g_smiles, name, rt, type, mass1, mass2, mass3, hits, comments, clusterbands,</span>
        <span class="c1">#best_well, best_purity, overlaps, mass+, mass-, time, conflicts]</span>
        <span class="n">values</span> <span class="o">=</span> <span class="p">{</span>
            <span class="mi">0</span><span class="p">:</span> <span class="n">containing_wells</span><span class="p">,</span>
            <span class="mi">1</span><span class="p">:</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
            <span class="mi">2</span><span class="p">:</span> <span class="sa">f</span><span class="s1">&#39;Impurity</span><span class="si">{</span><span class="n">index</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span>
            <span class="mi">3</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
            <span class="mi">4</span><span class="p">:</span> <span class="s2">&quot;Impurity&quot;</span><span class="p">,</span>
            <span class="mi">5</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> 
            <span class="mi">6</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> 
            <span class="mi">7</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> 
            <span class="mi">8</span><span class="p">:</span> <span class="n">hits</span><span class="p">,</span>
            <span class="mi">9</span><span class="p">:</span> <span class="n">comments</span><span class="p">,</span>
            <span class="mi">10</span><span class="p">:</span> <span class="p">[</span><span class="n">mean_rt</span><span class="p">],</span>
            <span class="mi">11</span><span class="p">:</span> <span class="n">getUserReadableWell</span><span class="p">(</span><span class="n">best_well</span><span class="p">),</span>
            <span class="mi">12</span><span class="p">:</span> <span class="n">best_purity</span><span class="p">,</span>
            <span class="mi">13</span><span class="p">:</span> <span class="p">[],</span>
            <span class="mi">14</span><span class="p">:</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">mass_plus</span><span class="p">),</span>
            <span class="mi">15</span><span class="p">:</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">mass_minus</span><span class="p">),</span>
            <span class="mi">16</span><span class="p">:</span> <span class="n">mean_rt</span><span class="p">,</span>
            <span class="mi">17</span><span class="p">:</span> <span class="p">[]</span>

            
        <span class="p">}</span>
        <span class="c1">#Plot an annotated chromatogram for each of the impurities</span>
        <span class="n">annotate_peaks</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">bindex</span><span class="p">,</span> <span class="n">brow</span> <span class="ow">in</span> <span class="n">compoundDF</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">brow</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]</span> <span class="o">!=</span> <span class="s2">&quot;Impurity&quot;</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">brow</span><span class="p">[</span><span class="s2">&quot;hits&quot;</span><span class="p">][</span><span class="s2">&quot;green&quot;</span><span class="p">]</span> <span class="k">if</span> <span class="n">i</span><span class="p">[</span><span class="s2">&quot;well&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">best_well</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">annotate_peaks</span><span class="o">.</span><span class="n">append</span><span class="p">({</span>
                            <span class="s2">&quot;cpname&quot;</span><span class="p">:</span> <span class="n">brow</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span> 
                            <span class="s2">&quot;time&quot;</span><span class="p">:</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;time&quot;</span><span class="p">]</span>
                            <span class="p">})</span>
        <span class="n">annotate_peaks</span><span class="o">.</span><span class="n">append</span><span class="p">({</span>
            <span class="s2">&quot;cpname&quot;</span><span class="p">:</span> <span class="sa">f</span><span class="s1">&#39;Impurity</span><span class="si">{</span><span class="n">index</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span> 
            <span class="s2">&quot;time&quot;</span><span class="p">:</span> <span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">cluster</span> <span class="k">if</span> <span class="n">i</span><span class="p">[</span><span class="s2">&quot;well&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">best_well</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="p">})</span>
        <span class="c1">#Get the ms data for the relevant peak in the best_well</span>
        <span class="n">ms_plus</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="s2">&quot;MS+&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">cluster</span> <span class="k">if</span> <span class="n">i</span><span class="p">[</span><span class="s2">&quot;well&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">best_well</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">ms_minus</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="s2">&quot;MS-&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">cluster</span> <span class="k">if</span> <span class="n">i</span><span class="p">[</span><span class="s2">&quot;well&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">best_well</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">pStart</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="s2">&quot;pStart&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">cluster</span> <span class="k">if</span> <span class="n">i</span><span class="p">[</span><span class="s2">&quot;well&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">best_well</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">pEnd</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="s2">&quot;pEnd&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">cluster</span> <span class="k">if</span> <span class="n">i</span><span class="p">[</span><span class="s2">&quot;well&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">best_well</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        
        <span class="c1">#Submit all data to plotChroma function</span>
        <span class="k">try</span><span class="p">:</span>  
            <span class="n">plotChroma</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Impurity</span><span class="si">{</span><span class="n">index</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">best_well</span><span class="p">,</span> <span class="n">chroma</span><span class="p">[</span><span class="n">best_well</span><span class="p">],</span> 
                    <span class="n">pStart</span><span class="p">,</span> <span class="n">pEnd</span><span class="p">,</span> 
                    <span class="n">annotate_peaks</span><span class="p">,</span> <span class="n">save_dir</span><span class="p">,</span> <span class="n">ms_plus</span><span class="p">,</span> <span class="n">ms_minus</span><span class="p">,</span> <span class="s2">&quot;Unknown Parent Mass&quot;</span><span class="p">)</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;A chromatogram was plotted for Impurity</span><span class="si">{</span><span class="n">index</span><span class="si">}</span><span class="s1"> from well </span><span class="si">{</span><span class="n">best_well</span><span class="si">}</span><span class="s1">.&#39;</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;No chromatogram could be plotted. Data not found.&quot;</span><span class="p">)</span>
        
        <span class="c1">#Append all data about impurity to the compoundDF</span>
        <span class="n">compoundDF</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;Impurity</span><span class="si">{</span><span class="n">index</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">values</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
        <span class="n">impurities</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Impurity</span><span class="si">{</span><span class="n">index</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    
    <span class="c1">#If 1 or more impurities were found, plot a hit validation graph to display these. </span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">clusters</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
        <span class="n">total_wells</span> <span class="o">=</span> <span class="n">options</span><span class="o">.</span><span class="n">plate_col_no</span> <span class="o">*</span> <span class="n">options</span><span class="o">.</span><span class="n">plate_row_no</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="o">-</span><span class="n">total_wells</span><span class="o">*</span><span class="mf">0.25</span><span class="p">,</span> <span class="n">total_wells</span><span class="o">*</span><span class="mf">1.1</span><span class="p">)</span>
        <span class="c1">#Plot a hit validation graph for all clusters to more easily display the results.</span>
        <span class="c1">#Save this to the graphs folder. </span>
        <span class="n">palette</span> <span class="o">=</span> <span class="n">cm</span><span class="o">.</span><span class="n">rainbow</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">clusters</span><span class="p">)))</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">cluster</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">clusters</span><span class="p">):</span>
            <span class="n">x</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">y</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">peak</span> <span class="ow">in</span> <span class="n">cluster</span><span class="p">:</span>
                <span class="n">x</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">peak</span><span class="p">[</span><span class="s2">&quot;well&quot;</span><span class="p">])</span>
                <span class="n">y</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">peak</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">])</span>

            <span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">color</span> <span class="o">=</span> <span class="n">palette</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

            <span class="c1">#Annotate the graph with the average retention time of each cluster</span>
            
            <span class="n">mean_rt</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">mean</span><span class="p">([</span><span class="n">peak</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">peak</span> <span class="ow">in</span> <span class="n">cluster</span><span class="p">]),</span> <span class="mi">2</span><span class="p">)</span>

            <span class="n">ax</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Imp</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">: </span><span class="si">{</span><span class="n">mean_rt</span><span class="si">}</span><span class="s1"> min.&#39;</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="n">total_wells</span><span class="o">*</span><span class="mf">0.22</span><span class="p">,</span> <span class="n">mean_rt</span><span class="p">],</span> 
                        <span class="n">verticalalignment</span><span class="o">=</span><span class="s1">&#39;center&#39;</span><span class="p">)</span>     

        <span class="c1">#Label the graph and axes, and save to the output directory.   </span>
        <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;All Frequent Impurities Found&quot;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Well&quot;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Retention Time /min&quot;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">save_dir</span><span class="si">}</span><span class="s1">/graphs/impuritychart.jpg&#39;</span><span class="p">,</span> <span class="nb">format</span> <span class="o">=</span> <span class="s2">&quot;jpg&quot;</span><span class="p">)</span>    
        <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    
    <span class="c1">#Return a list of impurity names for use when building the HTML output. </span>
    <span class="k">return</span> <span class="n">impurities</span></div>

<div class="viewcode-block" id="generateOutputTable"><a class="viewcode-back" href="../pyparse_det.html#PyParse.generateOutputTable">[docs]</a><span class="k">def</span> <span class="nf">generateOutputTable</span><span class="p">(</span><span class="n">compoundDF</span><span class="p">,</span> <span class="n">internalSTD</span><span class="p">,</span> <span class="n">SMs</span><span class="p">,</span> <span class="n">products</span><span class="p">,</span> <span class="n">by_products</span><span class="p">,</span> <span class="n">total_area_abs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Reformats the validated hits into a pandas table ready for visualisation and export. </span>
<span class="sd">    </span>
<span class="sd">    :param compoundDF: The pandas datatable containing all compounds with their respective hits.</span>
<span class="sd">    :param internalSTD: the name of the internalSTD</span>
<span class="sd">    :param SMs: a list of indices for the starting materials</span>
<span class="sd">    :param products: a list of indices for the products</span>
<span class="sd">    :param by_products: a list of indices for the by-products</span>
<span class="sd">    :param total_area_abs: A float corresponding to the sum of all peak_area_absolutes</span>
<span class="sd">    </span>
<span class="sd">    :return: A Pandas table named outputTable</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">outputTable</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="c1">#generate the structure of the table so that it is independant of the </span>
    <span class="c1">#hits that are found</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">options</span><span class="o">.</span><span class="n">plate_row_no</span> <span class="o">*</span> <span class="n">options</span><span class="o">.</span><span class="n">plate_col_no</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">well_id</span> <span class="o">=</span> <span class="n">getUserReadableWell</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="n">goingIn</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;well_no&quot;</span><span class="p">:</span> <span class="n">i</span><span class="p">,</span>
            <span class="s2">&quot;Well&quot;</span><span class="p">:</span> <span class="n">well_id</span><span class="p">,</span>
            <span class="s2">&quot;SMILES&quot;</span><span class="p">:</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
            <span class="s2">&quot;canonSMILES&quot;</span><span class="p">:</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
            <span class="s2">&quot;SMarea&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
            <span class="s2">&quot;SMareaAbs&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
            <span class="s2">&quot;Parea&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
            <span class="s2">&quot;PareaAbs&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
            <span class="s2">&quot;STDarea&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
            <span class="s2">&quot;STDareaAbs&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
            <span class="s2">&quot;Uarea&quot;</span><span class="p">:</span> <span class="mi">100</span><span class="p">,</span>
            <span class="s2">&quot;UareaAbs&quot;</span><span class="p">:</span> <span class="n">total_area_abs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
            <span class="s2">&quot;corrSMarea&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
            <span class="s2">&quot;corrParea&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
            <span class="s2">&quot;corrSTDarea&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
            <span class="s2">&quot;P/SM+P&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
            <span class="s2">&quot;P/STD&quot;</span><span class="p">:</span><span class="mi">0</span>
            <span class="p">}</span>
        <span class="k">for</span> <span class="n">by_prod</span> <span class="ow">in</span> <span class="n">by_products</span><span class="p">:</span>            
            <span class="n">name</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">by_prod</span><span class="si">}</span><span class="s1">area&#39;</span>
            <span class="n">corr_name</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;corr</span><span class="si">{</span><span class="n">by_prod</span><span class="si">}</span><span class="s1">area&#39;</span>
            <span class="n">abs_name</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">by_prod</span><span class="si">}</span><span class="s1">areaAbs&#39;</span>
            <span class="n">name_std</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">by_prod</span><span class="si">}</span><span class="s1">/STD&#39;</span>

            <span class="n">goingIn</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">goingIn</span><span class="p">[</span><span class="n">abs_name</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">goingIn</span><span class="p">[</span><span class="n">corr_name</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">goingIn</span><span class="p">[</span><span class="n">name_std</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>   

        <span class="n">outputTable</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">goingIn</span>  

    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">compoundDF</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
        <span class="c1">#Add the product SMILES to the outputTable</span>
        <span class="k">if</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span> <span class="ow">in</span> <span class="n">products</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">location</span> <span class="ow">in</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;locations&quot;</span><span class="p">]:</span>
                <span class="n">outputTable</span><span class="p">[</span><span class="n">location</span><span class="p">][</span><span class="s2">&quot;canonSMILES&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">index</span>
                <span class="n">outputTable</span><span class="p">[</span><span class="n">location</span><span class="p">][</span><span class="s2">&quot;SMILES&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;g_smiles&quot;</span><span class="p">]</span>
        
        
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;hits&quot;</span><span class="p">][</span><span class="s2">&quot;green&quot;</span><span class="p">])</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">max_area</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="n">hit</span><span class="p">[</span><span class="s2">&quot;area&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">hit</span> <span class="ow">in</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;hits&quot;</span><span class="p">][</span><span class="s2">&quot;green&quot;</span><span class="p">]])</span>
            
            <span class="k">for</span> <span class="n">hit</span> <span class="ow">in</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;hits&quot;</span><span class="p">][</span><span class="s2">&quot;green&quot;</span><span class="p">]:</span>
                            
                <span class="k">if</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span> <span class="ow">in</span> <span class="n">SMs</span><span class="p">:</span>
                    <span class="n">outputTable</span><span class="p">[</span><span class="n">hit</span><span class="p">[</span><span class="s2">&quot;well&quot;</span><span class="p">]][</span><span class="s2">&quot;SMarea&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">hit</span><span class="p">[</span><span class="s2">&quot;area&quot;</span><span class="p">]</span>
                    <span class="n">outputTable</span><span class="p">[</span><span class="n">hit</span><span class="p">[</span><span class="s2">&quot;well&quot;</span><span class="p">]][</span><span class="s2">&quot;SMareaAbs&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">hit</span><span class="p">[</span><span class="s2">&quot;areaAbs&quot;</span><span class="p">]</span>
                    <span class="n">outputTable</span><span class="p">[</span><span class="n">hit</span><span class="p">[</span><span class="s2">&quot;well&quot;</span><span class="p">]][</span><span class="s2">&quot;corrSMarea&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">hit</span><span class="p">[</span><span class="s2">&quot;area&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="n">max_area</span>
                    <span class="n">outputTable</span><span class="p">[</span><span class="n">hit</span><span class="p">[</span><span class="s2">&quot;well&quot;</span><span class="p">]][</span><span class="s2">&quot;Uarea&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">outputTable</span><span class="p">[</span><span class="n">hit</span><span class="p">[</span><span class="s2">&quot;well&quot;</span><span class="p">]][</span><span class="s2">&quot;Uarea&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="n">hit</span><span class="p">[</span><span class="s2">&quot;area&quot;</span><span class="p">]</span>
                    <span class="n">outputTable</span><span class="p">[</span><span class="n">hit</span><span class="p">[</span><span class="s2">&quot;well&quot;</span><span class="p">]][</span><span class="s2">&quot;UareaAbs&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">outputTable</span><span class="p">[</span><span class="n">hit</span><span class="p">[</span><span class="s2">&quot;well&quot;</span><span class="p">]][</span><span class="s2">&quot;UareaAbs&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="n">hit</span><span class="p">[</span><span class="s2">&quot;areaAbs&quot;</span><span class="p">]</span>
                <span class="k">elif</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">internalSTD</span><span class="p">:</span>
                    <span class="n">outputTable</span><span class="p">[</span><span class="n">hit</span><span class="p">[</span><span class="s2">&quot;well&quot;</span><span class="p">]][</span><span class="s2">&quot;STDarea&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">hit</span><span class="p">[</span><span class="s2">&quot;area&quot;</span><span class="p">]</span>
                    <span class="n">outputTable</span><span class="p">[</span><span class="n">hit</span><span class="p">[</span><span class="s2">&quot;well&quot;</span><span class="p">]][</span><span class="s2">&quot;STDareaAbs&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">hit</span><span class="p">[</span><span class="s2">&quot;areaAbs&quot;</span><span class="p">]</span>
                    <span class="n">outputTable</span><span class="p">[</span><span class="n">hit</span><span class="p">[</span><span class="s2">&quot;well&quot;</span><span class="p">]][</span><span class="s2">&quot;corrSTDarea&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">hit</span><span class="p">[</span><span class="s2">&quot;area&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="n">max_area</span>
                    <span class="n">outputTable</span><span class="p">[</span><span class="n">hit</span><span class="p">[</span><span class="s2">&quot;well&quot;</span><span class="p">]][</span><span class="s2">&quot;Uarea&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">outputTable</span><span class="p">[</span><span class="n">hit</span><span class="p">[</span><span class="s2">&quot;well&quot;</span><span class="p">]][</span><span class="s2">&quot;Uarea&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="n">hit</span><span class="p">[</span><span class="s2">&quot;area&quot;</span><span class="p">]</span>
                    <span class="n">outputTable</span><span class="p">[</span><span class="n">hit</span><span class="p">[</span><span class="s2">&quot;well&quot;</span><span class="p">]][</span><span class="s2">&quot;UareaAbs&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">outputTable</span><span class="p">[</span><span class="n">hit</span><span class="p">[</span><span class="s2">&quot;well&quot;</span><span class="p">]][</span><span class="s2">&quot;UareaAbs&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="n">hit</span><span class="p">[</span><span class="s2">&quot;areaAbs&quot;</span><span class="p">]</span>
                <span class="k">elif</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span> <span class="ow">in</span> <span class="n">products</span><span class="p">:</span>
                    <span class="n">outputTable</span><span class="p">[</span><span class="n">hit</span><span class="p">[</span><span class="s2">&quot;well&quot;</span><span class="p">]][</span><span class="s2">&quot;Parea&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">hit</span><span class="p">[</span><span class="s2">&quot;area&quot;</span><span class="p">]</span>
                    <span class="n">outputTable</span><span class="p">[</span><span class="n">hit</span><span class="p">[</span><span class="s2">&quot;well&quot;</span><span class="p">]][</span><span class="s2">&quot;PareaAbs&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">hit</span><span class="p">[</span><span class="s2">&quot;areaAbs&quot;</span><span class="p">]</span>
                    <span class="n">outputTable</span><span class="p">[</span><span class="n">hit</span><span class="p">[</span><span class="s2">&quot;well&quot;</span><span class="p">]][</span><span class="s2">&quot;corrParea&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">hit</span><span class="p">[</span><span class="s2">&quot;area&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="n">max_area</span>
                    <span class="n">outputTable</span><span class="p">[</span><span class="n">hit</span><span class="p">[</span><span class="s2">&quot;well&quot;</span><span class="p">]][</span><span class="s2">&quot;Uarea&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">outputTable</span><span class="p">[</span><span class="n">hit</span><span class="p">[</span><span class="s2">&quot;well&quot;</span><span class="p">]][</span><span class="s2">&quot;Uarea&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="n">hit</span><span class="p">[</span><span class="s2">&quot;area&quot;</span><span class="p">]</span>
                    <span class="n">outputTable</span><span class="p">[</span><span class="n">hit</span><span class="p">[</span><span class="s2">&quot;well&quot;</span><span class="p">]][</span><span class="s2">&quot;UareaAbs&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">outputTable</span><span class="p">[</span><span class="n">hit</span><span class="p">[</span><span class="s2">&quot;well&quot;</span><span class="p">]][</span><span class="s2">&quot;UareaAbs&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="n">hit</span><span class="p">[</span><span class="s2">&quot;areaAbs&quot;</span><span class="p">]</span>

                    

                <span class="k">elif</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span> <span class="ow">in</span> <span class="n">by_products</span><span class="p">:</span>
                    <span class="n">name</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span><span class="si">}</span><span class="s1">area&#39;</span>
                    <span class="n">corr_name</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;corr</span><span class="si">{</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span><span class="si">}</span><span class="s1">area&#39;</span>
                    <span class="n">abs_name</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span><span class="si">}</span><span class="s1">areaAbs&#39;</span>
                    <span class="n">outputTable</span><span class="p">[</span><span class="n">hit</span><span class="p">[</span><span class="s2">&quot;well&quot;</span><span class="p">]][</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">hit</span><span class="p">[</span><span class="s2">&quot;area&quot;</span><span class="p">]</span>
                    <span class="n">outputTable</span><span class="p">[</span><span class="n">hit</span><span class="p">[</span><span class="s2">&quot;well&quot;</span><span class="p">]][</span><span class="n">abs_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">hit</span><span class="p">[</span><span class="s2">&quot;areaAbs&quot;</span><span class="p">]</span>
                    <span class="n">outputTable</span><span class="p">[</span><span class="n">hit</span><span class="p">[</span><span class="s2">&quot;well&quot;</span><span class="p">]][</span><span class="n">corr_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">hit</span><span class="p">[</span><span class="s2">&quot;area&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="n">max_area</span>
                    <span class="n">outputTable</span><span class="p">[</span><span class="n">hit</span><span class="p">[</span><span class="s2">&quot;well&quot;</span><span class="p">]][</span><span class="s2">&quot;Uarea&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">outputTable</span><span class="p">[</span><span class="n">hit</span><span class="p">[</span><span class="s2">&quot;well&quot;</span><span class="p">]][</span><span class="s2">&quot;Uarea&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="n">hit</span><span class="p">[</span><span class="s2">&quot;area&quot;</span><span class="p">]</span>
                    <span class="n">outputTable</span><span class="p">[</span><span class="n">hit</span><span class="p">[</span><span class="s2">&quot;well&quot;</span><span class="p">]][</span><span class="s2">&quot;UareaAbs&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">outputTable</span><span class="p">[</span><span class="n">hit</span><span class="p">[</span><span class="s2">&quot;well&quot;</span><span class="p">]][</span><span class="s2">&quot;UareaAbs&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="n">hit</span><span class="p">[</span><span class="s2">&quot;areaAbs&quot;</span><span class="p">]</span>
    
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">options</span><span class="o">.</span><span class="n">plate_row_no</span> <span class="o">*</span> <span class="n">options</span><span class="o">.</span><span class="n">plate_col_no</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>

        <span class="n">well</span> <span class="o">=</span> <span class="n">outputTable</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="c1">#reset any non-sensical values that arise as a result of miniscule rounding errors</span>
        <span class="c1">#for the unidentified area (Uarea, UareaAbs)</span>
        <span class="k">if</span> <span class="nb">round</span><span class="p">(</span><span class="n">well</span><span class="p">[</span><span class="s2">&quot;Uarea&quot;</span><span class="p">])</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">round</span><span class="p">(</span><span class="n">well</span><span class="p">[</span><span class="s2">&quot;UareaAbs&quot;</span><span class="p">])</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span> 
            <span class="n">well</span><span class="p">[</span><span class="s2">&quot;Uarea&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">well</span><span class="p">[</span><span class="s2">&quot;UareaAbs&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">well</span><span class="p">[</span><span class="s2">&quot;PareaAbs&quot;</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">well</span><span class="p">[</span><span class="s2">&quot;SMareaAbs&quot;</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">well</span><span class="p">[</span><span class="s2">&quot;P/SM+P&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">well</span><span class="p">[</span><span class="s2">&quot;PareaAbs&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="n">well</span><span class="p">[</span><span class="s2">&quot;SMareaAbs&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="n">well</span><span class="p">[</span><span class="s2">&quot;PareaAbs&quot;</span><span class="p">]),</span> <span class="mi">2</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">well</span><span class="p">[</span><span class="s2">&quot;STDareaAbs&quot;</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            
            <span class="k">if</span> <span class="n">well</span><span class="p">[</span><span class="s2">&quot;PareaAbs&quot;</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">well</span><span class="p">[</span><span class="s2">&quot;P/STD&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">well</span><span class="p">[</span><span class="s2">&quot;PareaAbs&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="n">well</span><span class="p">[</span><span class="s2">&quot;STDareaAbs&quot;</span><span class="p">],</span> <span class="mi">2</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">by_prod</span> <span class="ow">in</span> <span class="n">by_products</span><span class="p">:</span>
                <span class="n">name_std</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">by_prod</span><span class="si">}</span><span class="s1">/STD&#39;</span>
                <span class="n">name</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">by_prod</span><span class="si">}</span><span class="s1">areaAbs&#39;</span>
                <span class="n">well</span><span class="p">[</span><span class="n">name_std</span><span class="p">]</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">well</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">/</span> <span class="n">well</span><span class="p">[</span><span class="s2">&quot;STDareaAbs&quot;</span><span class="p">],</span> <span class="mi">2</span><span class="p">)</span>

    <span class="c1">#generate pandas dataframe, and sort it on the well_no (index)</span>
    <span class="n">dataframe</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">outputTable</span><span class="p">,</span> <span class="n">orient</span><span class="o">=</span><span class="s2">&quot;index&quot;</span><span class="p">)</span>
    <span class="n">dataframe</span><span class="o">.</span><span class="n">sort_index</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    
    <span class="c1">#Generate composite metrics like P/STD, and add them to the dataframe. </span>
    <span class="n">corrP_SM</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">corrP_STD</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">compoundDF</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span> <span class="ow">in</span> <span class="n">products</span><span class="p">:</span>
            <span class="n">new_slice</span> <span class="o">=</span> <span class="n">dataframe</span><span class="o">.</span><span class="n">loc</span><span class="p">[(</span><span class="n">dataframe</span><span class="p">[</span><span class="s2">&quot;well_no&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;locations&quot;</span><span class="p">])),</span> 
                                      <span class="p">[</span><span class="s2">&quot;well_no&quot;</span><span class="p">,</span> <span class="s2">&quot;P/SM+P&quot;</span><span class="p">,</span> <span class="s2">&quot;P/STD&quot;</span><span class="p">]]</span>
            
            <span class="n">max_val_P_SM</span> <span class="o">=</span> <span class="n">new_slice</span><span class="p">[</span><span class="s2">&quot;P/SM+P&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
            <span class="n">max_val_P_STD</span> <span class="o">=</span> <span class="n">new_slice</span><span class="p">[</span><span class="s2">&quot;P/STD&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
            
            <span class="k">for</span> <span class="n">sindex</span><span class="p">,</span> <span class="n">srow</span> <span class="ow">in</span> <span class="n">new_slice</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">max_val_P_SM</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">corrP_SM</span><span class="p">[</span><span class="n">srow</span><span class="p">[</span><span class="s2">&quot;well_no&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">srow</span><span class="p">[</span><span class="s2">&quot;P/SM+P&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="n">max_val_P_SM</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">corrP_SM</span><span class="p">[</span><span class="n">srow</span><span class="p">[</span><span class="s2">&quot;well_no&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">if</span> <span class="n">max_val_P_STD</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">corrP_STD</span><span class="p">[</span><span class="n">srow</span><span class="p">[</span><span class="s2">&quot;well_no&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">srow</span><span class="p">[</span><span class="s2">&quot;P/STD&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="n">max_val_P_STD</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">corrP_STD</span><span class="p">[</span><span class="n">srow</span><span class="p">[</span><span class="s2">&quot;well_no&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">0</span> 

        <span class="k">elif</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span> <span class="ow">in</span> <span class="n">by_products</span><span class="p">:</span>
            <span class="n">name_std</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">by_prod</span><span class="si">}</span><span class="s1">/STD&#39;</span>
            <span class="n">new_slice</span> <span class="o">=</span> <span class="n">dataframe</span><span class="o">.</span><span class="n">loc</span><span class="p">[(</span><span class="n">dataframe</span><span class="p">[</span><span class="s2">&quot;well_no&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;locations&quot;</span><span class="p">])),</span> 
                                      <span class="p">[</span><span class="s2">&quot;well_no&quot;</span><span class="p">,</span> <span class="n">name_std</span><span class="p">]]</span>
            <span class="n">max_val_P_STD</span> <span class="o">=</span> <span class="n">new_slice</span><span class="p">[</span><span class="n">name_std</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
            <span class="n">new_column</span> <span class="o">=</span> <span class="p">{}</span>
                 
            <span class="k">for</span> <span class="n">sindex</span><span class="p">,</span> <span class="n">srow</span> <span class="ow">in</span> <span class="n">new_slice</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">max_val_P_STD</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">new_column</span><span class="p">[</span><span class="n">srow</span><span class="p">[</span><span class="s2">&quot;well_no&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">srow</span><span class="p">[</span><span class="n">name_std</span><span class="p">]</span> <span class="o">/</span> <span class="n">max_val_P_STD</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">new_column</span><span class="p">[</span><span class="n">srow</span><span class="p">[</span><span class="s2">&quot;well_no&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">going_in</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">options</span><span class="o">.</span><span class="n">plate_row_no</span> <span class="o">*</span> <span class="n">options</span><span class="o">.</span><span class="n">plate_col_no</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">new_column</span><span class="p">:</span>
                    <span class="n">going_in</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_column</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">going_in</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">dataframe</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;corr</span><span class="si">{</span><span class="n">by_prod</span><span class="si">}</span><span class="s1">/STD&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">going_in</span>
    
    <span class="c1">#Convert the above data to a list so that it can be added</span>
    <span class="c1">#as a column to the dataframe. </span>
    <span class="n">going_in_sm</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">going_in_std</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">options</span><span class="o">.</span><span class="n">plate_row_no</span> <span class="o">*</span> <span class="n">options</span><span class="o">.</span><span class="n">plate_col_no</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="ow">in</span> <span class="n">corrP_SM</span><span class="p">:</span>
            <span class="n">going_in_sm</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">corrP_SM</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">going_in_std</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">corrP_STD</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">going_in_sm</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">going_in_std</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    
    <span class="n">dataframe</span><span class="p">[</span><span class="s2">&quot;corrP/SM+P&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">going_in_sm</span>    
    <span class="n">dataframe</span><span class="p">[</span><span class="s2">&quot;corrP/STD&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">going_in_std</span>

    <span class="k">return</span> <span class="n">dataframe</span></div>

<div class="viewcode-block" id="findOverlap"><a class="viewcode-back" href="../pyparse_det.html#PyParse.findOverlap">[docs]</a><span class="k">def</span> <span class="nf">findOverlap</span><span class="p">(</span><span class="n">dataTable</span><span class="p">,</span> <span class="n">well</span><span class="p">,</span> <span class="n">time</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Provided with the dataTable and a retention time+well of interest, </span>
<span class="sd">    this function will look for any overlapping peaks, and return the retention </span>
<span class="sd">    times of those peaks to the user. </span>
<span class="sd">    </span>
<span class="sd">    :param dataTable: A dictionary of list of dicts, indexed by well</span>
<span class="sd">    :param well: An integer to describe the well number</span>
<span class="sd">    :param time: The retention time, as a float, of the peak of interest</span>
<span class="sd">    </span>
<span class="sd">    :return: A list of overlaps</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">overlaps</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="c1">#Sort the peaks in that well by their retention time</span>
    <span class="n">peaks</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">dataTable</span><span class="p">[</span><span class="n">well</span><span class="p">],</span> <span class="n">key</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">])</span>
    
    <span class="c1">#Select the peak index for the compound of interest</span>
    <span class="n">peak_index</span> <span class="o">=</span> <span class="p">[</span><span class="n">index</span> <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">peaks</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">time</span><span class="p">]</span>
    
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">peak_index</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">peak_index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        
        <span class="c1">#Find if the peak prior has the same end time as this peak&#39;s start time</span>
        <span class="k">if</span> <span class="n">index</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span> 
            <span class="k">if</span> <span class="n">peaks</span><span class="p">[</span><span class="n">index</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;pEnd&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">peaks</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="s2">&quot;pStart&quot;</span><span class="p">]:</span>
                <span class="n">overlaps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">peaks</span><span class="p">[</span><span class="n">index</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;time&quot;</span><span class="p">])</span>
        <span class="c1">#Find if the peak after has the same start time as this peak&#39;s end time</span>
        <span class="k">if</span> <span class="n">index</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">peaks</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">peaks</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="s2">&quot;pEnd&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">peaks</span><span class="p">[</span><span class="n">index</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;pStart&quot;</span><span class="p">]:</span>
                <span class="n">overlaps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">peaks</span><span class="p">[</span><span class="n">index</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;time&quot;</span><span class="p">])</span>
        
    <span class="k">return</span> <span class="n">overlaps</span></div>

<div class="viewcode-block" id="findPotentialConflicts"><a class="viewcode-back" href="../pyparse_det.html#PyParse.findPotentialConflicts">[docs]</a><span class="k">def</span> <span class="nf">findPotentialConflicts</span><span class="p">(</span><span class="n">compoundDF</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find any products which are in danger of overlapping with other compounds that</span>
<span class="sd">    are expected in the same well. </span>
<span class="sd">    This function is useful as the program may not detect SM (etc) for that peak/well</span>
<span class="sd">    because the mass_conf is too low, but the user should still be warned that there </span>
<span class="sd">    may be a problem. </span>

<span class="sd">    :param compoundDF: Pandas datatable for compounds</span>
<span class="sd">    :return: A text output for that compound. </span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">output</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">compoundDF</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
        
        <span class="n">new_slice</span> <span class="o">=</span> <span class="n">compoundDF</span><span class="o">.</span><span class="n">loc</span><span class="p">[(((</span><span class="n">compoundDF</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">abs</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mf">0.02</span><span class="p">)</span>
                                    <span class="o">&amp;</span> <span class="p">(</span><span class="n">compoundDF</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span> <span class="o">!=</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">])</span>
                                    <span class="o">&amp;</span> <span class="p">(</span><span class="n">compoundDF</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))]</span>
        <span class="n">close_compounds</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">bindex</span><span class="p">,</span> <span class="n">brow</span> <span class="ow">in</span> <span class="n">new_slice</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
            <span class="n">overlap</span> <span class="o">=</span> <span class="nb">len</span><span class="p">([</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;locations&quot;</span><span class="p">]</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">brow</span><span class="p">[</span><span class="s2">&quot;locations&quot;</span><span class="p">]])</span>
            <span class="k">if</span> <span class="n">overlap</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">close_compounds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">brow</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">])</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">close_compounds</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">text</span> <span class="o">=</span> <span class="s2">&quot;&lt;strong&gt;The compound was found to have a similar retention time as &quot;</span>
            <span class="k">for</span> <span class="n">cpindex</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">close_compounds</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">cpindex</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">close_compounds</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                    <span class="n">text</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">text</span><span class="si">}{</span><span class="n">close_compounds</span><span class="p">[</span><span class="n">cpindex</span><span class="p">]</span><span class="si">}</span><span class="s1">, &#39;</span>
                <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">close_compounds</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">text</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">text</span><span class="si">}</span><span class="s1">and </span><span class="si">{</span><span class="n">close_compounds</span><span class="p">[</span><span class="n">cpindex</span><span class="p">]</span><span class="si">}</span><span class="s1">. &#39;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">text</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">text</span><span class="si">}{</span><span class="n">close_compounds</span><span class="p">[</span><span class="n">cpindex</span><span class="p">]</span><span class="si">}</span><span class="s1">. &#39;</span>
            <span class="n">text</span> <span class="o">=</span> <span class="n">text</span> <span class="o">+</span> <span class="s2">&quot;The user should check this result manually.&lt;/strong&gt;&quot;</span>
            <span class="n">output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">text</span> <span class="o">=</span> <span class="s2">&quot;No potential conflicts found.&quot;</span>
            <span class="n">output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">output</span>        </div>

<div class="viewcode-block" id="plotHitValidationGraph"><a class="viewcode-back" href="../pyparse_det.html#PyParse.plotHitValidationGraph">[docs]</a><span class="k">def</span> <span class="nf">plotHitValidationGraph</span><span class="p">(</span><span class="n">cpname</span><span class="p">,</span> <span class="n">validatedHits</span><span class="p">,</span> <span class="n">save_dir</span><span class="p">,</span> <span class="n">cluster_bands</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Plots all the hit peaks in a scatter graph of peaktime vs</span>
<span class="sd">    well, colour coded by whether the hit was included or discarded</span>
<span class="sd">    from the final output. </span>
<span class="sd">    </span>
<span class="sd">    :param cpname: a string for the name of the compound of interest</span>
<span class="sd">    :param validatedHits: a dict, where each header contains a list of dicts</span>
<span class="sd">    :param save_dir: File directory for where to save the matplotlib figure</span>
<span class="sd">    :param cluster_bands: A list of the average retention times for each cluster.</span>
<span class="sd">    </span>
<span class="sd">    :return: jpg of the hit validation graph saved to output directory </span>
<span class="sd">    &quot;&quot;&quot;</span>  
    
    <span class="c1">#Find the largest peak area, and the minimum/maximum retention times</span>
    <span class="c1">#of the hits to be plotted</span>
    <span class="n">allHits</span> <span class="o">=</span> <span class="n">validatedHits</span><span class="p">[</span><span class="s2">&quot;green&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="n">validatedHits</span><span class="p">[</span><span class="s2">&quot;discarded&quot;</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">cluster</span> <span class="ow">in</span> <span class="n">validatedHits</span><span class="p">[</span><span class="s2">&quot;discarded_by_cluster&quot;</span><span class="p">]:</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">cluster</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">allHits</span> <span class="o">=</span> <span class="n">allHits</span> <span class="o">+</span> <span class="n">value</span>
    
    <span class="n">max_size</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">allHits</span><span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="s2">&quot;area&quot;</span><span class="p">])[</span><span class="s2">&quot;area&quot;</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">allHits</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">0</span>
    <span class="n">max_time</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">allHits</span><span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">])[</span><span class="s2">&quot;time&quot;</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">allHits</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">0</span>
    <span class="n">min_time</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">allHits</span><span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">])[</span><span class="s2">&quot;time&quot;</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">allHits</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">0</span>

    
    <span class="c1">#Used to calculate the size of each hit on the graph</span>
    <span class="k">if</span> <span class="n">max_size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">size_ratio</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">/</span> <span class="n">max_size</span>

        <span class="c1">#A list of possible markers used for plotting each hit, based on which</span>
        <span class="c1">#cluster that hit was assigned to (see validateHits fn)</span>
        <span class="n">t_markers</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;o&quot;</span><span class="p">,</span> <span class="s2">&quot;v&quot;</span><span class="p">,</span> <span class="s2">&quot;^&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;&quot;</span><span class="p">,</span> <span class="s2">&quot;&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;1&quot;</span><span class="p">,</span> <span class="s2">&quot;s&quot;</span><span class="p">,</span> <span class="s2">&quot;p&quot;</span><span class="p">,</span> <span class="s2">&quot;P&quot;</span><span class="p">,</span> <span class="s2">&quot;+&quot;</span><span class="p">,</span> 
                     <span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;D&quot;</span><span class="p">,</span> <span class="s2">&quot;2&quot;</span><span class="p">,</span> <span class="s2">&quot;3&quot;</span><span class="p">,</span> <span class="s2">&quot;4&quot;</span><span class="p">,</span> <span class="s2">&quot;8&quot;</span><span class="p">,</span> <span class="s2">&quot;h&quot;</span><span class="p">,</span> <span class="s2">&quot;H&quot;</span><span class="p">,</span> <span class="s2">&quot;d&quot;</span><span class="p">,</span> <span class="s2">&quot;_&quot;</span><span class="p">]</span>

        <span class="c1">#Determine the right scale for the y-axis now to avoid scaling issues </span>
        <span class="c1">#between different points in the scatter graph            </span>
        <span class="n">y_lims</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">max_time</span> <span class="o">-</span> <span class="n">min_time</span> <span class="o">&lt;</span> <span class="mf">0.1</span><span class="p">:</span>
            <span class="n">mid_point</span> <span class="o">=</span> <span class="p">(</span><span class="n">max_time</span> <span class="o">+</span> <span class="n">min_time</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
            <span class="n">y_lims</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">mid_point</span> <span class="o">-</span> <span class="mf">0.05</span>
            <span class="n">y_lims</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">mid_point</span> <span class="o">+</span> <span class="mf">0.05</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">y_lims</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">min_time</span>
            <span class="n">y_lims</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">max_time</span>
        
        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>  

        <span class="c1">#Set the axis ranges   </span>
        <span class="n">total_wells</span> <span class="o">=</span> <span class="n">options</span><span class="o">.</span><span class="n">plate_col_no</span> <span class="o">*</span> <span class="n">options</span><span class="o">.</span><span class="n">plate_row_no</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="o">-</span><span class="n">total_wells</span><span class="o">*</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">total_wells</span><span class="o">*</span><span class="mf">1.1</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="n">y_lims</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="p">(</span><span class="n">y_lims</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">y_lims</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="mi">10</span><span class="p">,</span> <span class="n">y_lims</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">y_lims</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">y_lims</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="mi">10</span><span class="p">)</span>
        
        <span class="c1">#Plot all hits that were used in the analysis</span>
        <span class="k">for</span> <span class="n">hit</span> <span class="ow">in</span> <span class="n">validatedHits</span><span class="p">[</span><span class="s2">&quot;green&quot;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">hit</span><span class="p">[</span><span class="s2">&quot;cluster&quot;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">t_markers</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">thismarker</span> <span class="o">=</span> <span class="s2">&quot;o&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">thismarker</span> <span class="o">=</span> <span class="n">t_markers</span><span class="p">[</span><span class="n">hit</span><span class="p">[</span><span class="s2">&quot;cluster&quot;</span><span class="p">]]</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">hit</span><span class="p">[</span><span class="s2">&quot;well&quot;</span><span class="p">],</span> <span class="n">hit</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">],</span> <span class="n">s</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">hit</span><span class="p">[</span><span class="s2">&quot;area&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="n">size_ratio</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> 
                        <span class="n">marker</span> <span class="o">=</span> <span class="n">thismarker</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;black&quot;</span><span class="p">)</span>
        
        <span class="c1">#Plot all hits that were discarded in favour of a better hit</span>
        <span class="k">for</span> <span class="n">hit</span> <span class="ow">in</span> <span class="n">validatedHits</span><span class="p">[</span><span class="s2">&quot;discarded&quot;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">hit</span><span class="p">[</span><span class="s2">&quot;cluster&quot;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">t_markers</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">thismarker</span> <span class="o">=</span> <span class="s2">&quot;o&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">thismarker</span> <span class="o">=</span> <span class="n">t_markers</span><span class="p">[</span><span class="n">hit</span><span class="p">[</span><span class="s2">&quot;cluster&quot;</span><span class="p">]]</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">hit</span><span class="p">[</span><span class="s2">&quot;well&quot;</span><span class="p">],</span> <span class="n">hit</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">],</span> <span class="n">s</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">hit</span><span class="p">[</span><span class="s2">&quot;area&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="n">size_ratio</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> 
                        <span class="n">marker</span> <span class="o">=</span> <span class="n">thismarker</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">)</span>
        
        <span class="c1">#Plot all hits that were discarded by cluster</span>
        <span class="k">for</span> <span class="n">cluster</span> <span class="ow">in</span> <span class="n">validatedHits</span><span class="p">[</span><span class="s2">&quot;discarded_by_cluster&quot;</span><span class="p">]:</span>   
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">cluster</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">for</span> <span class="n">hit</span> <span class="ow">in</span> <span class="n">value</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">hit</span><span class="p">[</span><span class="s2">&quot;cluster&quot;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">t_markers</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                        <span class="n">thismarker</span> <span class="o">=</span> <span class="s2">&quot;o&quot;</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">thismarker</span> <span class="o">=</span> <span class="n">t_markers</span><span class="p">[</span><span class="n">hit</span><span class="p">[</span><span class="s2">&quot;cluster&quot;</span><span class="p">]]</span>
                    <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">hit</span><span class="p">[</span><span class="s2">&quot;well&quot;</span><span class="p">],</span> <span class="n">hit</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">],</span> <span class="n">s</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">hit</span><span class="p">[</span><span class="s2">&quot;area&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="n">size_ratio</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> 
                                <span class="n">marker</span> <span class="o">=</span> <span class="n">thismarker</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">)</span>
        
        <span class="c1">#Annotate the graph with the average retention time of each cluster</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cluster_bands</span><span class="p">)):</span>
            <span class="n">x</span> <span class="o">=</span> <span class="o">-</span><span class="n">total_wells</span><span class="o">*</span><span class="mf">0.17</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">cluster_bands</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;C</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">: </span><span class="si">{</span><span class="n">cluster_bands</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">}</span><span class="s1"> min.&#39;</span><span class="p">,</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">])</span>

        <span class="c1">#Label the graph and axes, and save to the output directory.   </span>
        <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="n">cpname</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Well&quot;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Retention Time /min&quot;</span><span class="p">)</span>
        
        <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">save_dir</span><span class="si">}</span><span class="s1">graphs/hits-</span><span class="si">{</span><span class="n">cpname</span><span class="si">}</span><span class="s1">.jpg&#39;</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s2">&quot;jpg&quot;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">()</span></div>

    


<div class="viewcode-block" id="plotChroma"><a class="viewcode-back" href="../pyparse_det.html#PyParse.plotChroma">[docs]</a><span class="k">def</span> <span class="nf">plotChroma</span><span class="p">(</span><span class="n">cpname</span><span class="p">,</span> <span class="n">wellno</span><span class="p">,</span> <span class="n">trace</span><span class="p">,</span> <span class="n">pStart</span><span class="p">,</span> <span class="n">pEnd</span><span class="p">,</span> <span class="n">annotate_peaks</span><span class="p">,</span> <span class="n">save_dir</span><span class="p">,</span> 
               <span class="n">ms_plus</span><span class="p">,</span> <span class="n">ms_minus</span><span class="p">,</span> <span class="n">mass1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Plots the LCMS trace with labels for compounds found for a specific well,</span>
<span class="sd">    and highlights a particular peak of interest, providing m/z data for that</span>
<span class="sd">    peak. </span>

<span class="sd">    :param cpname: a string of the compound name</span>
<span class="sd">    :param wellno: an integer representing the well</span>
<span class="sd">    :param trace: a list [x-values, y-values] to plot the Uv chromatogram </span>
<span class="sd">    :param pStart: a float for the time where a specific peak begins</span>
<span class="sd">    :param pEnd: a float for the time where a specific peak ends. </span>
<span class="sd">    :param annotate_peaks: a list of dictionaries for peaks to annotate</span>
<span class="sd">    :param save_dir: a string for the output directory</span>
<span class="sd">    :param ms_plus: a list [x-values, y-values] for MS+ spectrometric data</span>
<span class="sd">    :param ms_minus: a list [x-values, y-values] for MS- spectrometric data</span>
<span class="sd">    :param mass1: the isotopic mass of a compound, to which +1/-1 should be added</span>
<span class="sd">        to get to an expected observed mass (typically parent isotopic mass)</span>
<span class="sd">    </span>
<span class="sd">    :return: jpg of the chromatogram saved to output directory</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">fig</span><span class="p">,</span> <span class="p">(</span><span class="n">a0</span><span class="p">,</span> <span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">)</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">gridspec_kw</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;height_ratios&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">]})</span>
    
    <span class="c1">#Function to plot the mass spectrometric data</span>
    <span class="k">def</span> <span class="nf">plotMS</span><span class="p">(</span><span class="n">axes</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">title</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">y</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
            <span class="n">x</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">y</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        
        <span class="n">axes</span><span class="o">.</span><span class="n">bar</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">width</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">axes</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">title</span><span class="p">)</span>
        <span class="n">axes</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">200</span><span class="p">)</span>
        
        <span class="n">last_annotation</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">highest_mass</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">peak</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">peak</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">20</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">math</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">peak</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">last_annotation</span><span class="p">,</span> <span class="n">abs_tol</span> <span class="o">=</span> <span class="mi">3</span><span class="p">):</span>
                    <span class="n">axes</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">peak</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="n">peak</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">15</span><span class="p">,</span> <span class="n">peak</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">20</span><span class="p">],</span> <span class="n">ha</span><span class="o">=</span><span class="s2">&quot;center&quot;</span><span class="p">,</span> 
                                  <span class="n">va</span><span class="o">=</span><span class="s2">&quot;bottom&quot;</span><span class="p">,</span> <span class="n">rotation</span><span class="o">=</span><span class="mi">90</span><span class="p">,</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">8</span><span class="p">)</span>
                    <span class="n">axes</span><span class="o">.</span><span class="n">arrow</span><span class="p">(</span><span class="n">peak</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">10</span><span class="p">,</span> <span class="n">peak</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">18</span><span class="p">,</span> <span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="o">-</span><span class="mi">8</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">axes</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">peak</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="n">peak</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">peak</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="n">ha</span><span class="o">=</span><span class="s2">&quot;center&quot;</span><span class="p">,</span> 
                                  <span class="n">va</span><span class="o">=</span><span class="s2">&quot;bottom&quot;</span><span class="p">,</span> <span class="n">rotation</span><span class="o">=</span><span class="mi">90</span><span class="p">,</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">8</span><span class="p">)</span>
                <span class="n">last_annotation</span> <span class="o">=</span> <span class="n">peak</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">peak</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">highest_mass</span><span class="p">:</span>
                    <span class="n">highest_mass</span> <span class="o">=</span> <span class="n">peak</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        
        <span class="c1">#Configure mass spec axis to reach at least 1000, but higher if necessary</span>
        <span class="c1">#With some additional headroom so that peaks are not obscured by the edge</span>
        <span class="c1">#of the plot</span>
        <span class="k">if</span> <span class="n">highest_mass</span> <span class="o">&gt;</span> <span class="mi">950</span><span class="p">:</span>
            <span class="n">axes</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">((</span><span class="n">highest_mass</span> <span class="o">+</span> <span class="mi">100</span><span class="p">)</span><span class="o">/</span><span class="mi">100</span><span class="p">)</span><span class="o">*</span><span class="mi">100</span><span class="p">)</span> 
        <span class="k">else</span><span class="p">:</span>
            <span class="n">axes</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>
    
    <span class="c1">#Plot both MS- and MS+    </span>
    <span class="n">plotMS</span><span class="p">(</span><span class="n">a0</span><span class="p">,</span> <span class="n">ms_minus</span><span class="p">,</span> <span class="s2">&quot;MS-&quot;</span><span class="p">)</span>
    <span class="n">plotMS</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">ms_plus</span><span class="p">,</span> <span class="s2">&quot;MS+&quot;</span><span class="p">)</span>

    <span class="c1">#Plot the UV chromatogram</span>
    <span class="n">a2</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">trace</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">trace</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

    <span class="c1">#label the graph and axes</span>
    <span class="n">label</span> <span class="o">=</span> <span class="n">getUserReadableWell</span><span class="p">(</span><span class="n">wellno</span><span class="p">)</span>
    <span class="n">fig</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">cpname</span><span class="si">}</span><span class="s1"> (</span><span class="si">{</span><span class="n">mass1</span><span class="si">}</span><span class="s1">): Well </span><span class="si">{</span><span class="n">label</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="n">a2</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Time /min&quot;</span><span class="p">)</span>
    <span class="n">a2</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;AUs&quot;</span><span class="p">)</span>

    <span class="c1">#Find the index of the start and end times of the peak</span>
    <span class="c1">#that should be highlighted. </span>
    <span class="k">if</span> <span class="n">pStart</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">pEnd</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">x_index_start</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">enumerate</span><span class="p">(</span><span class="n">trace</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> 
                        <span class="n">key</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">pStart</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">x_index_end</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">enumerate</span><span class="p">(</span><span class="n">trace</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> 
                        <span class="n">key</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">pEnd</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">diff</span> <span class="o">=</span> <span class="n">trace</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">x_index_end</span><span class="p">]</span> <span class="o">-</span> <span class="n">trace</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">x_index_start</span><span class="p">]</span>
        
        <span class="c1">#Generate a second curve which can be used to specifically fill the hit</span>
        <span class="c1">#well. </span>
        <span class="n">second_curve</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">trace</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="c1">#Calculate where the baseline value should be based on the relative</span>
            <span class="c1">#heights at the start and end of the peak. </span>
            <span class="k">if</span> <span class="n">index</span> <span class="o">&gt;=</span> <span class="n">x_index_start</span> <span class="ow">and</span> <span class="n">index</span> <span class="o">&lt;=</span> <span class="n">x_index_end</span><span class="p">:</span>
                <span class="n">new_val</span> <span class="o">=</span> <span class="p">(</span><span class="n">trace</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">x_index_start</span><span class="p">]</span> 
                    <span class="o">+</span> <span class="n">diff</span><span class="o">*</span><span class="p">((</span><span class="n">index</span> <span class="o">-</span> <span class="n">x_index_start</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">x_index_end</span> <span class="o">-</span> <span class="n">x_index_start</span><span class="p">)))</span>
                <span class="k">if</span> <span class="n">new_val</span> <span class="o">&gt;</span> <span class="n">trace</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">index</span><span class="p">]:</span>
                    <span class="n">second_curve</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">trace</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">index</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">second_curve</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_val</span><span class="p">)</span>
            <span class="c1">#For all x-values that don&#39;t fill inside the hit peak, </span>
            <span class="c1">#the second curve should match the LCMS trace so that these areas don&#39;t</span>
            <span class="c1">#get filled. </span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">second_curve</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">trace</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">index</span><span class="p">])</span>
            
    <span class="c1">#Annotate the peaks that were matched to a compound using an arrow</span>
    <span class="c1">#and dynamic positioning for clarity</span>
    <span class="n">annotate_peaks</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">])</span>
    <span class="n">last_x_position</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">max_x</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">trace</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">annotate_peaks</span><span class="p">):</span>

        <span class="n">x_index</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">enumerate</span><span class="p">(</span><span class="n">trace</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> 
                      <span class="n">key</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">i</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">]))[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">annotate_peaks</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">h_align</span> <span class="o">=</span> <span class="s2">&quot;right&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">h_align</span> <span class="o">=</span> <span class="s2">&quot;left&quot;</span>
        <span class="k">if</span> <span class="n">index</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">max_x</span> <span class="o">/</span> <span class="mi">40</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">index</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">annotate_peaks</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="p">(</span><span class="n">max_x</span> <span class="o">/</span> <span class="mi">40</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">arrow_props</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">arrowstyle</span><span class="o">=</span><span class="s2">&quot;-&gt;&quot;</span><span class="p">,</span> <span class="n">connectionstyle</span><span class="o">=</span><span class="s2">&quot;arc3&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">math</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">last_x_position</span><span class="p">,</span> <span class="n">i</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">]</span><span class="o">+</span><span class="n">offset</span><span class="p">,</span> <span class="n">abs_tol</span> <span class="o">=</span> <span class="p">(</span><span class="n">max_x</span> <span class="o">/</span> <span class="mi">20</span><span class="p">))</span> <span class="ow">and</span> <span class="n">index</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">annotate_peaks</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">h_align</span> <span class="o">==</span> <span class="s2">&quot;left&quot;</span><span class="p">:</span>
                <span class="n">h_align</span> <span class="o">=</span> <span class="s2">&quot;right&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">h_align</span> <span class="o">=</span> <span class="s2">&quot;left&quot;</span>

        <span class="k">if</span> <span class="n">index</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">i</span><span class="p">[</span><span class="s2">&quot;cpname&quot;</span><span class="p">]</span><span class="si">}</span><span class="s1">: </span><span class="si">{</span><span class="n">i</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">]</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">xy</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">],</span> <span class="n">trace</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">x_index</span><span class="p">]),</span> 
                        <span class="n">xytext</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">]</span><span class="o">+</span><span class="n">offset</span><span class="p">,</span> <span class="mi">120</span><span class="p">),</span> <span class="n">horizontalalignment</span><span class="o">=</span><span class="n">h_align</span><span class="p">,</span>
                        <span class="n">arrowprops</span> <span class="o">=</span> <span class="n">arrow_props</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">i</span><span class="p">[</span><span class="s2">&quot;cpname&quot;</span><span class="p">]</span><span class="si">}</span><span class="s1">: </span><span class="si">{</span><span class="n">i</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">]</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">xy</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">],</span> <span class="n">trace</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">x_index</span><span class="p">]),</span> 
                        <span class="n">xytext</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">]</span><span class="o">+</span><span class="n">offset</span><span class="p">,</span> <span class="mi">110</span><span class="p">),</span> <span class="n">horizontalalignment</span><span class="o">=</span><span class="n">h_align</span><span class="p">,</span>
                        <span class="n">arrowprops</span> <span class="o">=</span> <span class="n">arrow_props</span><span class="p">)</span>
        <span class="n">last_x_position</span> <span class="o">=</span> <span class="n">i</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">]</span><span class="o">+</span><span class="n">offset</span>
    <span class="n">min_y</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">trace</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    
    <span class="c1">#Set axis limits</span>
    <span class="n">a2</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="n">min_y</span> <span class="o">-</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">130</span><span class="p">)</span>
    <span class="n">a2</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="o">-</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">max_x</span><span class="o">+</span><span class="mf">0.1</span><span class="p">)</span>

    <span class="c1">#plot a hatched region if the filter_by_rt option </span>
    <span class="c1">#has been used</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">options</span><span class="o">.</span><span class="n">filter_by_rt</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        
        <span class="c1">#Set default yvalues to match that of chromatogram trace</span>
        <span class="n">hatched_ymin</span><span class="p">,</span> <span class="n">hatched_ymax</span> <span class="o">=</span> <span class="p">[],[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">trace</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">hatched_ymin</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="n">hatched_ymax</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">new_range</span> <span class="ow">in</span> <span class="n">options</span><span class="o">.</span><span class="n">filter_by_rt</span><span class="p">:</span>
            <span class="n">minx</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">new_range</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;-&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">())</span>
            <span class="n">maxx</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">new_range</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;-&quot;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">())</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">trace</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="c1">#Amend any values such between specified ranges</span>
                <span class="k">if</span> <span class="n">j</span> <span class="o">&gt;</span> <span class="n">minx</span> <span class="ow">and</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">maxx</span><span class="p">:</span>
                    <span class="n">hatched_ymax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">130</span>
                    <span class="n">hatched_ymin</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">min_y</span> <span class="o">-</span> <span class="mi">10</span>
        <span class="c1">#fill between on graph, using traceparency = 0.3</span>
        <span class="n">a2</span><span class="o">.</span><span class="n">fill_between</span><span class="p">(</span><span class="n">trace</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">hatched_ymin</span><span class="p">,</span> <span class="n">hatched_ymax</span><span class="p">,</span> <span class="n">hatch</span> <span class="o">=</span> <span class="s2">&quot;/&quot;</span><span class="p">,</span> <span class="n">alpha</span> <span class="o">=</span> <span class="mf">0.3</span><span class="p">)</span>

    <span class="c1">#Fill to highlight the peak of interest </span>
    <span class="k">if</span> <span class="n">pStart</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">pEnd</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">a2</span><span class="o">.</span><span class="n">fill_between</span><span class="p">(</span><span class="n">trace</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">second_curve</span><span class="p">,</span> <span class="n">trace</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">)</span>

    <span class="c1">#Set the number of tick points for each axis. </span>
    <span class="n">a2</span><span class="o">.</span><span class="n">locator_params</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="n">nbins</span><span class="o">=</span><span class="mi">6</span><span class="p">)</span>
    <span class="n">a2</span><span class="o">.</span><span class="n">locator_params</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">nbins</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
    
    <span class="c1">#Save graph to output directory. </span>
    <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">save_dir</span><span class="si">}</span><span class="s1">graphs/chroma-</span><span class="si">{</span><span class="n">cpname</span><span class="si">}</span><span class="s1">-best.jpg&#39;</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s2">&quot;jpg&quot;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">()</span></div>

<div class="viewcode-block" id="plotPieCharts"><a class="viewcode-back" href="../pyparse_det.html#PyParse.plotPieCharts">[docs]</a><span class="k">def</span> <span class="nf">plotPieCharts</span><span class="p">(</span><span class="n">zvalue</span><span class="p">,</span> <span class="n">outputTable</span><span class="p">,</span> <span class="n">save_dir</span><span class="p">,</span> <span class="n">by_products</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Plots a set of pie charts for the full plate</span>
<span class="sd">    using the full dataset. The size of the pie chart is dependant on</span>
<span class="sd">    the value in the datatable for the column specified by zvalue</span>
<span class="sd">    </span>
<span class="sd">    :param zvalue: a string corresponding to the desired output metric (e.g. P/STD)</span>
<span class="sd">    :param outputTable: a pandas datatable</span>
<span class="sd">    :param save_dir: a string for the output directory</span>
<span class="sd">    :param by_products: a list of names of byproducts</span>
<span class="sd">    </span>
<span class="sd">    :return: jpg of the piecharts saved to output directory</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1">#declare color palette</span>
    <span class="n">palette</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;black&quot;</span><span class="p">,</span> <span class="s2">&quot;brown&quot;</span><span class="p">,</span> <span class="s2">&quot;red&quot;</span><span class="p">,</span> <span class="s2">&quot;sienna&quot;</span><span class="p">,</span>
                <span class="s2">&quot;peru&quot;</span><span class="p">,</span> <span class="s2">&quot;orange&quot;</span><span class="p">,</span> <span class="s2">&quot;gold&quot;</span><span class="p">,</span> <span class="s2">&quot;olive&quot;</span><span class="p">,</span> <span class="s2">&quot;lawngreen&quot;</span><span class="p">,</span> <span class="s2">&quot;darkgreen&quot;</span><span class="p">,</span> <span class="s2">&quot;lime&quot;</span><span class="p">,</span> <span class="s2">&quot;aqua&quot;</span><span class="p">,</span> 
                <span class="s2">&quot;steelblue&quot;</span><span class="p">,</span> <span class="s2">&quot;slategray&quot;</span><span class="p">,</span> <span class="s2">&quot;navy&quot;</span><span class="p">]</span>
    
    
    <span class="k">def</span> <span class="nf">buildPies</span><span class="p">(</span><span class="n">chart_type</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Define function to build a trellised pie chart. </span>

<span class="sd">        :param chart_type: String defining whether this set of pie charts has fixed or variable </span>
<span class="sd">                            diameters</span>
<span class="sd">        </span>
<span class="sd">        :return: jpg of trellised pie chart saved to output folder</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1">#declare new subplots</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">axs</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">options</span><span class="o">.</span><span class="n">plate_row_no</span><span class="p">,</span> <span class="n">options</span><span class="o">.</span><span class="n">plate_col_no</span><span class="p">)</span>
        
        <span class="c1">#get maximum value, so diameter of all pies can be calculated in relation</span>
        <span class="c1">#to the best performing well. </span>
        <span class="n">max_val</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="n">row</span><span class="p">[</span><span class="n">zvalue</span><span class="p">]</span> <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">outputTable</span><span class="o">.</span><span class="n">iterrows</span><span class="p">()])</span>
        
        <span class="c1">#format data and generate pie charts</span>
        <span class="n">pies_baked</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">max_val</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            
            <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">outputTable</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
                <span class="n">pies_baked</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
                <span class="n">rowVal</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">((</span><span class="n">index</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">options</span><span class="o">.</span><span class="n">plate_col_no</span><span class="p">)</span>
                <span class="n">colVal</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">index</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">options</span><span class="o">.</span><span class="n">plate_col_no</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">chart_type</span> <span class="o">==</span> <span class="s2">&quot;fixed_width&quot;</span><span class="p">:</span>
                    <span class="n">chart_size</span> <span class="o">=</span> <span class="mf">0.95</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">chart_size</span> <span class="o">=</span>  <span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="n">zvalue</span><span class="p">]</span> <span class="o">/</span> <span class="n">max_val</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.95</span>

                <span class="n">color_tracker</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">colors</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">sum_byprod</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">row</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">by_prod</span><span class="si">}</span><span class="s1">area&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">by_prod</span> <span class="ow">in</span> <span class="n">by_products</span><span class="p">])</span>
                
                <span class="n">total</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;SMarea&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;Parea&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;STDarea&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="n">sum_byprod</span>
                <span class="c1">#the LCMS machine can calculate a total area of &gt;100% due to rounding errors</span>
                <span class="c1">#this needs to be corrected before the piechart is built</span>
                <span class="k">if</span> <span class="n">total</span> <span class="o">&gt;</span> <span class="mi">100</span><span class="p">:</span>
                    <span class="n">total</span> <span class="o">=</span> <span class="mi">100</span>
                <span class="n">data</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">if</span> <span class="n">chart_size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span> 
                    <span class="k">if</span> <span class="n">total</span> <span class="o">!=</span> <span class="mi">100</span><span class="p">:</span>
                        <span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">100</span><span class="o">-</span><span class="n">total</span><span class="p">)</span>
                        <span class="n">colors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;grey&quot;</span><span class="p">)</span>

                    <span class="k">if</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;SMarea&quot;</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;SMarea&quot;</span><span class="p">]))</span>
                        <span class="n">colors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;cyan&quot;</span><span class="p">)</span>

                    <span class="k">if</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;Parea&quot;</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;Parea&quot;</span><span class="p">]))</span>
                        <span class="n">colors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;yellow&quot;</span><span class="p">)</span>

                    <span class="k">if</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;STDarea&quot;</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;STDarea&quot;</span><span class="p">]))</span>
                        <span class="n">colors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;green&quot;</span><span class="p">)</span>
                    
                    <span class="k">for</span> <span class="n">by_prod</span> <span class="ow">in</span> <span class="n">by_products</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">by_prod</span><span class="si">}</span><span class="s1">area&#39;</span><span class="p">])</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">by_prod</span><span class="si">}</span><span class="s1">area&#39;</span><span class="p">]))</span>
                            <span class="n">colors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">palette</span><span class="p">[</span><span class="n">color_tracker</span><span class="p">])</span>
                        <span class="n">color_tracker</span> <span class="o">=</span> <span class="n">color_tracker</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1">#Set chart size to 0.01 to avoid a non-zero radius</span>
                    <span class="c1">#which causes matplotlib to fail. </span>
                    <span class="n">chart_size</span> <span class="o">=</span> <span class="mf">0.01</span>
                    
                
                <span class="k">if</span> <span class="n">options</span><span class="o">.</span><span class="n">plate_row_no</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">axs</span><span class="p">[</span><span class="n">colVal</span><span class="p">]</span><span class="o">.</span><span class="n">pie</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> 
                            <span class="n">textprops</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;size&quot;</span><span class="p">:</span> <span class="s2">&quot;smaller&quot;</span><span class="p">},</span> 
                            <span class="n">colors</span> <span class="o">=</span> <span class="n">colors</span><span class="p">,</span>  
                            <span class="n">radius</span><span class="o">=</span><span class="n">chart_size</span><span class="p">,</span>
                            <span class="n">normalize</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">options</span><span class="o">.</span><span class="n">plate_col_no</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">axs</span><span class="p">[</span><span class="n">rowVal</span><span class="p">]</span><span class="o">.</span><span class="n">pie</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> 
                            <span class="n">textprops</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;size&quot;</span><span class="p">:</span> <span class="s2">&quot;smaller&quot;</span><span class="p">},</span> 
                            <span class="n">colors</span> <span class="o">=</span> <span class="n">colors</span><span class="p">,</span>  
                            <span class="n">radius</span><span class="o">=</span><span class="n">chart_size</span><span class="p">,</span>
                            <span class="n">normalize</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">axs</span><span class="p">[</span><span class="n">rowVal</span><span class="p">,</span> <span class="n">colVal</span><span class="p">]</span><span class="o">.</span><span class="n">pie</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> 
                            <span class="n">textprops</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;size&quot;</span><span class="p">:</span> <span class="s2">&quot;smaller&quot;</span><span class="p">},</span> 
                            <span class="n">colors</span> <span class="o">=</span> <span class="n">colors</span><span class="p">,</span>  
                            <span class="n">radius</span><span class="o">=</span><span class="n">chart_size</span><span class="p">,</span>
                            <span class="n">normalize</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
                
        <span class="c1">#Remove any unused sections of the trellised pie chart</span>
        <span class="c1">#graph so that the visualisation is neater.         </span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">options</span><span class="o">.</span><span class="n">plate_col_no</span> <span class="o">*</span> <span class="p">(</span><span class="n">options</span><span class="o">.</span><span class="n">plate_row_no</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">rowVal</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">((</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">options</span><span class="o">.</span><span class="n">plate_col_no</span><span class="p">)</span>
            <span class="n">colVal</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">options</span><span class="o">.</span><span class="n">plate_col_no</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">pies_baked</span><span class="p">:</span>
                
                <span class="c1">#matplotlib axes drop a dimension </span>
                <span class="c1">#when that dimension is length = 1. </span>
                <span class="c1">#Adjust code to match</span>
                <span class="k">if</span> <span class="n">options</span><span class="o">.</span><span class="n">plate_row_no</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">delaxes</span><span class="p">(</span><span class="n">axs</span><span class="p">[</span><span class="n">colVal</span><span class="p">])</span>
                <span class="k">elif</span> <span class="n">options</span><span class="o">.</span><span class="n">plate_col_no</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">delaxes</span><span class="p">(</span><span class="n">axs</span><span class="p">[</span><span class="n">rowVal</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">delaxes</span><span class="p">(</span><span class="n">axs</span><span class="p">[</span><span class="n">rowVal</span><span class="p">,</span> <span class="n">colVal</span><span class="p">])</span>
           

        <span class="c1">#Add a key to the graph </span>
        <span class="n">lines</span> <span class="o">=</span> <span class="p">[</span><span class="n">Line2D</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;grey&quot;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">4</span><span class="p">),</span> 
                <span class="n">Line2D</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;cyan&quot;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">4</span><span class="p">),</span>
                <span class="n">Line2D</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;yellow&quot;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">4</span><span class="p">),</span>
                <span class="n">Line2D</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;green&quot;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">4</span><span class="p">),]</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Untagged&quot;</span><span class="p">,</span> <span class="s2">&quot;Reactant&quot;</span><span class="p">,</span> <span class="s2">&quot;Product&quot;</span><span class="p">,</span> <span class="s2">&quot;InternalSTD&quot;</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">by_products</span><span class="p">)):</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Line2D</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="n">palette</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">lw</span><span class="o">=</span><span class="mi">4</span><span class="p">))</span>
            <span class="n">labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">by_products</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">options</span><span class="o">.</span><span class="n">plate_row_no</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">axs</span><span class="p">[</span><span class="n">options</span><span class="o">.</span><span class="n">plate_col_no</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">lines</span><span class="p">,</span>
                    <span class="n">labels</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="s2">&quot;lower center&quot;</span><span class="p">,</span>
                    <span class="n">bbox_to_anchor</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">ncol</span><span class="o">=</span><span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span><span class="o">/</span><span class="mi">3</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">options</span><span class="o">.</span><span class="n">plate_col_no</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">axs</span><span class="p">[</span><span class="n">options</span><span class="o">.</span><span class="n">plate_row_no</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">lines</span><span class="p">,</span>
                    <span class="n">labels</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="s2">&quot;upper left&quot;</span><span class="p">,</span>
                    <span class="n">bbox_to_anchor</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">ncol</span><span class="o">=</span><span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span><span class="o">/</span><span class="mi">3</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">axs</span><span class="p">[</span><span class="n">options</span><span class="o">.</span><span class="n">plate_row_no</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">options</span><span class="o">.</span><span class="n">plate_col_no</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">lines</span><span class="p">,</span>
                    <span class="n">labels</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="s2">&quot;upper right&quot;</span><span class="p">,</span>
                    <span class="n">bbox_to_anchor</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="n">ncol</span><span class="o">=</span><span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span><span class="o">/</span><span class="mi">3</span><span class="p">))</span>
            
        <span class="c1">#Add titles to the graphs</span>
        <span class="k">if</span> <span class="n">chart_type</span> <span class="o">==</span> <span class="s2">&quot;fixed_width&quot;</span><span class="p">:</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="s2">&quot;Fixed Diameter Trellised Pie Charts&quot;</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mf">0.9</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Trellised Pie Charts Sized by </span><span class="si">{</span><span class="n">zvalue</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mf">0.9</span><span class="p">)</span>
        
        <span class="c1">#Save graph to output directory</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">save_dir</span><span class="si">}</span><span class="s1">graphs/piecharts_</span><span class="si">{</span><span class="n">chart_type</span><span class="si">}</span><span class="s1">.jpg&#39;</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s2">&quot;jpg&quot;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    
    <span class="n">buildPies</span><span class="p">(</span><span class="s2">&quot;fixed_width&quot;</span><span class="p">)</span>
    <span class="n">buildPies</span><span class="p">(</span><span class="s2">&quot;variable_width&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="plotHeatmaps"><a class="viewcode-back" href="../pyparse_det.html#PyParse.plotHeatmaps">[docs]</a><span class="k">def</span> <span class="nf">plotHeatmaps</span><span class="p">(</span><span class="n">outputTable</span><span class="p">,</span> <span class="n">save_dir</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Plots and saves heatmaps for the full dataset</span>
<span class="sd">    </span>
<span class="sd">    :param outputTable: a pandas datatable</span>
<span class="sd">    :param save_dir: a string for the output directory</span>
<span class="sd">    </span>
<span class="sd">    :return: jpg of the heatmap saved to output directory</span>
<span class="sd">    &quot;&quot;&quot;</span>

    
    <span class="n">zvalues</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;SMarea&quot;</span><span class="p">:</span> <span class="s2">&quot;SMarea&quot;</span><span class="p">,</span>
        <span class="s2">&quot;Parea&quot;</span><span class="p">:</span> <span class="s2">&quot;Parea&quot;</span><span class="p">,</span> 
        <span class="s2">&quot;conversion&quot;</span><span class="p">:</span> <span class="s2">&quot;P/SM+P&quot;</span><span class="p">,</span> 
        <span class="s2">&quot;ratio_to_IS&quot;</span><span class="p">:</span> <span class="s2">&quot;P/STD&quot;</span><span class="p">,</span>
        <span class="s2">&quot;corrSMarea&quot;</span><span class="p">:</span> <span class="s2">&quot;corrSMarea&quot;</span><span class="p">,</span>
        <span class="s2">&quot;corrParea&quot;</span><span class="p">:</span> <span class="s2">&quot;corrParea&quot;</span><span class="p">,</span> 
        <span class="s2">&quot;corrected_conversion&quot;</span><span class="p">:</span> <span class="s2">&quot;corrP/SM+P&quot;</span><span class="p">,</span>
        <span class="s2">&quot;corrected_ratio_to_IS&quot;</span><span class="p">:</span> <span class="s2">&quot;corrP/STD&quot;</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">zvalue</span> <span class="ow">in</span> <span class="n">zvalues</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        
        <span class="n">returnVal</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1">#convert output table to 2-D list that can be used to plot heatmap. </span>
        <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">outputTable</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
            <span class="n">rowVal</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">((</span><span class="n">index</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">options</span><span class="o">.</span><span class="n">plate_col_no</span><span class="p">))</span>
            <span class="n">colVal</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">index</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">options</span><span class="o">.</span><span class="n">plate_col_no</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">colVal</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">returnVal</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
                <span class="n">labels</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
            <span class="k">if</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;SampleID&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;No Data.&quot;</span><span class="p">:</span>
                <span class="n">labels</span><span class="p">[</span><span class="n">rowVal</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;-&quot;</span><span class="p">)</span>
                <span class="n">returnVal</span><span class="p">[</span><span class="n">rowVal</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">row</span><span class="p">[</span><span class="n">zvalue</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">labels</span><span class="p">[</span><span class="n">rowVal</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="n">zvalue</span><span class="p">]))</span>
                <span class="k">elif</span> <span class="n">row</span><span class="p">[</span><span class="n">zvalue</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">100</span><span class="p">:</span>
                    <span class="n">labels</span><span class="p">[</span><span class="n">rowVal</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">row</span><span class="p">[</span><span class="n">zvalue</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">labels</span><span class="p">[</span><span class="n">rowVal</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;0&quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">labels</span><span class="p">[</span><span class="n">rowVal</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="n">zvalue</span><span class="p">],</span><span class="mi">2</span><span class="p">))</span>

                <span class="n">returnVal</span><span class="p">[</span><span class="n">rowVal</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="n">zvalue</span><span class="p">])</span>

        <span class="c1">#Configure heatmap</span>
        <span class="n">pdTable</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">returnVal</span><span class="p">)</span>
        <span class="n">xLabels</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">options</span><span class="o">.</span><span class="n">plate_col_no</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
        <span class="n">yLabels</span> <span class="o">=</span> <span class="p">[</span><span class="nb">chr</span><span class="p">(</span><span class="nb">ord</span><span class="p">(</span><span class="s1">&#39;@&#39;</span><span class="p">)</span><span class="o">+</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">options</span><span class="o">.</span><span class="n">plate_row_no</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
        
        <span class="n">ax</span> <span class="o">=</span> <span class="n">sns</span><span class="o">.</span><span class="n">heatmap</span><span class="p">(</span><span class="n">pdTable</span><span class="p">,</span> <span class="n">xticklabels</span><span class="o">=</span><span class="n">xLabels</span><span class="p">,</span> <span class="n">yticklabels</span><span class="o">=</span><span class="n">yLabels</span><span class="p">,</span> <span class="n">cmap</span> <span class="o">=</span> <span class="s2">&quot;viridis&quot;</span><span class="p">,</span>
                        <span class="n">annot</span> <span class="o">=</span> <span class="n">labels</span><span class="p">,</span> <span class="n">cbar_kws</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;label&quot;</span><span class="p">:</span> <span class="n">zvalue</span><span class="p">},</span> <span class="n">fmt</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">set_ticks_position</span><span class="p">(</span><span class="s2">&quot;top&quot;</span><span class="p">)</span>
        
        <span class="c1">#Save heatmap to output directory</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">save_dir</span><span class="si">}</span><span class="s1">graphs/heatmap_</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s1">.jpg&#39;</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s2">&quot;jpg&quot;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">()</span></div>

<div class="viewcode-block" id="plotHistogram"><a class="viewcode-back" href="../pyparse_det.html#PyParse.plotHistogram">[docs]</a><span class="k">def</span> <span class="nf">plotHistogram</span><span class="p">(</span><span class="n">dataframe</span><span class="p">,</span> <span class="n">save_dir</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Takes the outputTable dataframe and generates a histogram for product %area</span>
<span class="sd">    to be saved in the output folder. </span>

<span class="sd">    :param dataframe: A Pandas dataframe (AKA outputTable)</span>
<span class="sd">    :param save_dir: a string for the output directory</span>
<span class="sd">    </span>
<span class="sd">    :return: jpg of the histogram saved to output directory</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1">#Configure histogram. Use colours for clear differentiation</span>
    <span class="c1">#between poor, medium and good results for that plate. </span>

    <span class="n">new_slice</span> <span class="o">=</span> <span class="n">dataframe</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">dataframe</span><span class="p">[</span><span class="s2">&quot;SampleID&quot;</span><span class="p">]</span> <span class="o">!=</span> <span class="s2">&quot;No Data.&quot;</span><span class="p">]</span>
    <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>

    <span class="n">N</span><span class="p">,</span> <span class="n">bins</span><span class="p">,</span> <span class="n">patches</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">new_slice</span><span class="p">[</span><span class="s2">&quot;Parea&quot;</span><span class="p">],</span> <span class="mi">50</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">16</span><span class="p">):</span>
        <span class="n">patches</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_facecolor</span><span class="p">(</span><span class="s2">&quot;blue&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">31</span><span class="p">):</span>
        <span class="n">patches</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_facecolor</span><span class="p">(</span><span class="s2">&quot;green&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">31</span><span class="p">,</span> <span class="mi">50</span><span class="p">):</span>
        <span class="n">patches</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_facecolor</span><span class="p">(</span><span class="s2">&quot;yellow&quot;</span><span class="p">)</span>
    
    <span class="c1">#Label axes and graph</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Product Percentage Area&quot;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Count&quot;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Product Percentage Area over Plate&quot;</span><span class="p">)</span>

    <span class="c1">#Save graph to output directory</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">save_dir</span><span class="si">}</span><span class="s1">graphs/histogram.jpg&#39;</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s2">&quot;jpg&quot;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">()</span></div>

<div class="viewcode-block" id="plotDonut"><a class="viewcode-back" href="../pyparse_det.html#PyParse.plotDonut">[docs]</a><span class="k">def</span> <span class="nf">plotDonut</span><span class="p">(</span><span class="n">dataframe</span><span class="p">,</span> <span class="n">save_dir</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Takes the outputTable dataframe and generates a donut chart for product %area</span>
<span class="sd">    to be saved in the output folder.</span>

<span class="sd">    :param dataframe: A Pandas dataframe (AKA outputTable)</span>
<span class="sd">    :param save_dir: a string for the output directory</span>
<span class="sd">    </span>
<span class="sd">    :return: Saved jpg of the donut chart</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="c1">#Bucket data into whether the plate gave high, medium, low product</span>
    <span class="c1">#purity, or whether no product was observed</span>
    <span class="n">Parea_list</span> <span class="o">=</span> <span class="n">dataframe</span><span class="p">[</span><span class="s2">&quot;Parea&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">to_list</span><span class="p">()</span>
    <span class="n">num_none_formed</span> <span class="o">=</span> <span class="nb">len</span><span class="p">([</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">Parea_list</span> <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">])</span>
    <span class="n">num_trace_formed</span> <span class="o">=</span> <span class="nb">len</span><span class="p">([</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">Parea_list</span> <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">20</span><span class="p">])</span>
    <span class="n">num_some_formed</span> <span class="o">=</span> <span class="nb">len</span><span class="p">([</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">Parea_list</span> <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">20</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">&lt;=</span><span class="mi">50</span><span class="p">])</span>
    <span class="n">num_lots_formed</span> <span class="o">=</span> <span class="nb">len</span><span class="p">([</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">Parea_list</span> <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">50</span><span class="p">])</span>

    <span class="c1">#Format data and labels</span>
    <span class="n">values</span> <span class="o">=</span> <span class="p">[</span><span class="n">num_none_formed</span><span class="p">,</span> <span class="n">num_trace_formed</span><span class="p">,</span> <span class="n">num_some_formed</span><span class="p">,</span> <span class="n">num_lots_formed</span><span class="p">]</span>
    <span class="n">colours</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;black&quot;</span><span class="p">,</span> <span class="s2">&quot;blue&quot;</span><span class="p">,</span> <span class="s2">&quot;green&quot;</span><span class="p">,</span> <span class="s2">&quot;yellow&quot;</span><span class="p">]</span>
    <span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s1">&#39;None formed: </span><span class="si">{</span><span class="n">num_none_formed</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;Poor: </span><span class="si">{</span><span class="n">num_trace_formed</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span>
        <span class="sa">f</span><span class="s1">&#39;Medium: </span><span class="si">{</span><span class="n">num_some_formed</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;Good: </span><span class="si">{</span><span class="n">num_lots_formed</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">]</span>
    
    <span class="c1">#Configure pie chart</span>
    <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">pie</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">colors</span> <span class="o">=</span> <span class="n">colours</span><span class="p">,</span> <span class="n">labels</span> <span class="o">=</span> <span class="n">labels</span><span class="p">)</span>

    <span class="c1">#Create and add white circle to make it a donut graph</span>
    <span class="n">centre_circle</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">Circle</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="mf">0.7</span><span class="p">,</span> <span class="n">fc</span><span class="o">=</span><span class="s2">&quot;white&quot;</span><span class="p">)</span>
    <span class="n">fig</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span><span class="o">.</span><span class="n">add_artist</span><span class="p">(</span><span class="n">centre_circle</span><span class="p">)</span>

    <span class="c1">#Label graph and save it to output directory</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Product Percentage Area over Plate&quot;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">save_dir</span><span class="si">}</span><span class="s1">graphs/donut.jpg&#39;</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s2">&quot;jpg&quot;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">()</span></div>


<div class="viewcode-block" id="generateMol"><a class="viewcode-back" href="../pyparse_det.html#PyParse.generateMol">[docs]</a><span class="k">def</span> <span class="nf">generateMol</span><span class="p">(</span><span class="n">smiles</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">save_dir</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generates a 2D rendering of the given structure and saves </span>
<span class="sd">    it as a .png</span>

<span class="sd">    :param smiles: a string (SMILES) of the compound</span>
<span class="sd">    :param name: a string corresponding to name of that compound</span>
<span class="sd">    :param save_dir: a string corresponding to the output directory</span>
<span class="sd">    </span>
<span class="sd">    :return: A .png rendering of the given compound</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">mol</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="n">smiles</span><span class="o">.</span><span class="n">strip</span><span class="p">())</span>
    <span class="n">_discard</span> <span class="o">=</span> <span class="n">AllChem</span><span class="o">.</span><span class="n">Compute2DCoords</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
    <span class="n">Draw</span><span class="o">.</span><span class="n">MolToFile</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">save_dir</span><span class="si">}</span><span class="s1">structures/</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1">.png&#39;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="mi">150</span><span class="p">))</span></div>

<div class="viewcode-block" id="genLocationHeatmaps"><a class="viewcode-back" href="../pyparse_det.html#PyParse.genLocationHeatmaps">[docs]</a><span class="k">def</span> <span class="nf">genLocationHeatmaps</span><span class="p">(</span><span class="n">cptable</span><span class="p">,</span> <span class="n">save_dir</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate a heatmap type graph to visualise the </span>
<span class="sd">    expected locations of each compound, based on the platemap that was provided. </span>

<span class="sd">    :param cptable: Pandas dataframe containing compounds</span>
<span class="sd">    :param save_dir: string describing the location of the output folder</span>
<span class="sd">    :output: Heatmaps saved to the output folder. </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">cptable</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>

        <span class="n">location_data</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">options</span><span class="o">.</span><span class="n">plate_col_no</span> <span class="o">*</span> <span class="n">options</span><span class="o">.</span><span class="n">plate_row_no</span><span class="p">):</span>
            <span class="n">rowVal</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">i</span> <span class="o">/</span> <span class="n">options</span><span class="o">.</span><span class="n">plate_col_no</span><span class="p">))</span>
            <span class="n">colVal</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="n">options</span><span class="o">.</span><span class="n">plate_col_no</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="n">colVal</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">location_data</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
                <span class="n">labels</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
            <span class="k">if</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span> <span class="ow">in</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;locations&quot;</span><span class="p">]:</span>
                <span class="n">location_data</span><span class="p">[</span><span class="n">rowVal</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">labels</span><span class="p">[</span><span class="n">rowVal</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">u</span><span class="s1">&#39;</span><span class="se">\u2713</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">location_data</span><span class="p">[</span><span class="n">rowVal</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">labels</span><span class="p">[</span><span class="n">rowVal</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
                

        <span class="n">pdTable</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">location_data</span><span class="p">)</span>
        <span class="n">xLabels</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">options</span><span class="o">.</span><span class="n">plate_col_no</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
        <span class="n">yLabels</span> <span class="o">=</span> <span class="p">[</span><span class="nb">chr</span><span class="p">(</span><span class="nb">ord</span><span class="p">(</span><span class="s1">&#39;@&#39;</span><span class="p">)</span><span class="o">+</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">options</span><span class="o">.</span><span class="n">plate_row_no</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
        
        <span class="n">ax</span> <span class="o">=</span> <span class="n">sns</span><span class="o">.</span><span class="n">heatmap</span><span class="p">(</span><span class="n">pdTable</span><span class="p">,</span> <span class="n">xticklabels</span><span class="o">=</span><span class="n">xLabels</span><span class="p">,</span> <span class="n">yticklabels</span><span class="o">=</span><span class="n">yLabels</span><span class="p">,</span> <span class="n">cmap</span> <span class="o">=</span> <span class="s2">&quot;viridis&quot;</span><span class="p">,</span> <span class="n">annot</span> <span class="o">=</span> <span class="n">labels</span><span class="p">,</span> <span class="n">fmt</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">set_ticks_position</span><span class="p">(</span><span class="s2">&quot;top&quot;</span><span class="p">)</span>
        
        <span class="c1">#Save heatmap to output directory</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">save_dir</span><span class="si">}</span><span class="s1">graphs/loc_heatmap_</span><span class="si">{</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span><span class="si">}</span><span class="s1">.jpg&#39;</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s2">&quot;jpg&quot;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>   </div>

<div class="viewcode-block" id="buildHTML"><a class="viewcode-back" href="../pyparse_det.html#PyParse.buildHTML">[docs]</a><span class="k">def</span> <span class="nf">buildHTML</span><span class="p">(</span><span class="n">save_dir</span><span class="p">,</span> <span class="n">compoundDF</span><span class="p">,</span> <span class="n">all_compounds</span><span class="p">,</span> <span class="n">impurities</span><span class="p">,</span> <span class="n">analysis_name</span><span class="p">,</span> <span class="n">times</span> <span class="o">=</span> <span class="p">{}):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Build a HTML output file using jinja2 and a html_template</span>
<span class="sd">    that is stored in the directory &quot;templates&quot;. </span>
<span class="sd">    </span>
<span class="sd">    :param save_dir: A string designating the output directory</span>
<span class="sd">    :param compoundDF: Pandas datatable containing all information on </span>
<span class="sd">                        the compounds used for analysis</span>
<span class="sd">    :param all_compounds: a list of all compound names</span>
<span class="sd">    :param impurities: a list of all impurity names</span>
<span class="sd">    :param analysis_name: User provided name for the analysis</span>
<span class="sd">    :param times: Optional parameter of a list of floats related to processing time</span>
<span class="sd">                    for each step of the analysis. </span>
<span class="sd">    :return: HTML file saved to save_dir </span>
<span class="sd">    &quot;&quot;&quot;</span>


    
    <span class="n">env</span> <span class="o">=</span> <span class="n">Environment</span><span class="p">(</span>
        <span class="n">loader</span> <span class="o">=</span> <span class="n">PackageLoader</span><span class="p">(</span><span class="s2">&quot;PyParse&quot;</span><span class="p">,</span> <span class="s2">&quot;templates&quot;</span><span class="p">)</span>
    <span class="p">)</span>

    <span class="n">template</span> <span class="o">=</span> <span class="n">env</span><span class="o">.</span><span class="n">get_template</span><span class="p">(</span><span class="s2">&quot;html_template.html&quot;</span><span class="p">)</span>

    <span class="n">cptablerows</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">compoundDF</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
        <span class="n">cptablerows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>
    

    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">save_dir</span><span class="si">}</span><span class="s1">/html_output.html&#39;</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fo</span><span class="p">:</span>
        <span class="n">fo</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">template</span><span class="o">.</span><span class="n">render</span><span class="p">(</span>
            <span class="n">cpnames</span> <span class="o">=</span> <span class="n">all_compounds</span><span class="p">,</span>
            <span class="n">imp_no</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">impurities</span><span class="p">),</span>
            <span class="n">cptablerows</span> <span class="o">=</span> <span class="n">cptablerows</span><span class="p">,</span> 
            <span class="n">save_dir</span> <span class="o">=</span> <span class="n">save_dir</span><span class="p">,</span>
            <span class="n">path</span> <span class="o">=</span> <span class="n">path</span><span class="p">,</span>
            <span class="n">times</span> <span class="o">=</span> <span class="n">times</span><span class="p">,</span>
            <span class="nb">round</span> <span class="o">=</span> <span class="nb">round</span><span class="p">,</span>
            <span class="n">pt</span> <span class="o">=</span> <span class="n">options</span><span class="o">.</span><span class="n">plot_type</span><span class="p">,</span> 
            <span class="n">analysis_name</span> <span class="o">=</span> <span class="n">analysis_name</span><span class="p">,</span>
            <span class="n">options</span> <span class="o">=</span> <span class="nb">vars</span><span class="p">(</span><span class="n">options</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="p">)</span>
    <span class="n">fo</span><span class="o">.</span><span class="n">close</span><span class="p">()</span> </div>



<div class="viewcode-block" id="main"><a class="viewcode-back" href="../pyparse_det.html#PyParse.main">[docs]</a><span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot; </span>
<span class="sd">    Provide an .rpt file and a csv containing the compounds in the </span>
<span class="sd">    plate to analyse the wells and return an output containing plots of compounds,</span>
<span class="sd">    key wells, and multiple output tables. </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">usage</span> <span class="o">=</span> <span class="s2">&quot;Automated LCMS Analysis and Data Extraction&quot;</span>

    <span class="c1">#Start timer</span>
    <span class="n">time_start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span>

    <span class="c1">#Setup argparse and load default values</span>
    <span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">(</span><span class="n">description</span> <span class="o">=</span> <span class="n">usage</span><span class="p">,</span>
                                     <span class="n">formatter_class</span><span class="o">=</span><span class="n">argparse</span><span class="o">.</span><span class="n">RawTextHelpFormatter</span><span class="p">,)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">set_defaults</span><span class="p">(</span>
                        <span class="n">validate</span> <span class="o">=</span> <span class="s2">&quot;True&quot;</span><span class="p">,</span>
                        <span class="n">verbose</span> <span class="o">=</span> <span class="s2">&quot;False&quot;</span><span class="p">,</span>

                        <span class="n">analysis_name</span> <span class="o">=</span> <span class="s2">&quot;PyParse Analysis&quot;</span><span class="p">,</span>

                        <span class="n">mass_abs_tol</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span>
                        <span class="n">time_abs_tol</span> <span class="o">=</span> <span class="mf">0.025</span><span class="p">,</span>
                        <span class="n">uv_abs_tol</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>

                        <span class="n">filter_by_rt</span> <span class="o">=</span> <span class="p">[],</span>


                        <span class="n">detector</span> <span class="o">=</span> <span class="s2">&quot;UV&quot;</span><span class="p">,</span>

                        <span class="n">min_peak_area</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span>
                        <span class="n">min_massconf_threshold</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
                        <span class="n">min_uv_threshold</span> <span class="o">=</span> <span class="mi">20</span><span class="p">,</span>

                        <span class="n">min_no_of_wells</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>

                        <span class="n">uv_match_threshold</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span>
                        <span class="n">uv_cluster_threshold</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span>
                        <span class="n">massconf_threshold</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span>
                        <span class="n">cluster_size_threshold</span> <span class="o">=</span> <span class="mf">0.8</span><span class="p">,</span>

                        <span class="c1">#Default values are set to 0, to easily monitor</span>
                        <span class="c1">#if the user has manually specified them.    </span>
                        <span class="n">plate_col_no</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
                        <span class="n">plate_row_no</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>

                        <span class="n">points_per_trace</span> <span class="o">=</span> <span class="mi">500</span><span class="p">,</span>
                        
                        <span class="n">mass_or_area</span> <span class="o">=</span> <span class="s2">&quot;mass_conf&quot;</span><span class="p">,</span>
                        <span class="n">plot_type</span> <span class="o">=</span> <span class="s2">&quot;Parea&quot;</span><span class="p">,</span> 
                        <span class="n">calc_higherions</span> <span class="o">=</span> <span class="s2">&quot;True&quot;</span><span class="p">,</span>
                        <span class="n">calc_boc</span> <span class="o">=</span> <span class="s2">&quot;True&quot;</span><span class="p">,</span>
                        
                        <span class="n">gen_csv</span> <span class="o">=</span> <span class="s2">&quot;True&quot;</span><span class="p">,</span>
                        <span class="n">gen_zip</span> <span class="o">=</span> <span class="s2">&quot;True&quot;</span><span class="p">,</span>

                        <span class="n">output</span> <span class="o">=</span> <span class="s2">&quot;output&quot;</span><span class="p">,</span>

                        <span class="n">instrument</span> <span class="o">=</span> <span class="s2">&quot;Waters&quot;</span><span class="p">,</span>

                        <span class="n">find_freq_imp</span> <span class="o">=</span> <span class="s2">&quot;True&quot;</span><span class="p">,</span>
                        <span class="p">)</span>
    
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s2">&quot;input_data&quot;</span><span class="p">,</span> <span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Input file/folder for analysis&quot;</span><span class="p">)</span>
    
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s2">&quot;input_csv&quot;</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Input .csv file containing compounds in plate&quot;</span><span class="p">)</span>
    
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s2">&quot;-o&quot;</span><span class="p">,</span> <span class="s2">&quot;--output&quot;</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s2">&quot;store&quot;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span> <span class="n">dest</span> <span class="o">=</span> <span class="s2">&quot;output&quot;</span><span class="p">,</span>
                        <span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Location to store output.&quot;</span><span class="p">)</span>
    
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s2">&quot;-V&quot;</span><span class="p">,</span> <span class="s2">&quot;--validate&quot;</span><span class="p">,</span> <span class="n">action</span> <span class="o">=</span> <span class="s2">&quot;store&quot;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span> <span class="n">dest</span> <span class="o">=</span> <span class="s2">&quot;validate&quot;</span><span class="p">,</span>
                       <span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;True/False: Run hit validation processes. </span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s2">&quot;-v&quot;</span><span class="p">,</span><span class="s2">&quot;--verbose&quot;</span><span class="p">,</span> <span class="n">action</span> <span class="o">=</span> <span class="s2">&quot;store&quot;</span><span class="p">,</span> <span class="nb">type</span> <span class="o">=</span> <span class="nb">str</span><span class="p">,</span> <span class="n">dest</span> <span class="o">=</span> <span class="s2">&quot;verbose&quot;</span><span class="p">,</span>
                     <span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Set to &#39;True&#39; to log verbosely.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s2">&quot;-mat&quot;</span><span class="p">,</span><span class="s2">&quot;--mass_abs_tol&quot;</span><span class="p">,</span><span class="n">action</span> <span class="o">=</span> <span class="s2">&quot;store&quot;</span><span class="p">,</span> <span class="nb">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">,</span> <span class="n">dest</span> <span class="o">=</span> <span class="s2">&quot;mass_abs_tol&quot;</span><span class="p">,</span>
                     <span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Variable to determine how close a m/z should be to match a given mass for a structure.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s2">&quot;-tat&quot;</span><span class="p">,</span><span class="s2">&quot;--time_abs_tol&quot;</span><span class="p">,</span><span class="n">action</span> <span class="o">=</span> <span class="s2">&quot;store&quot;</span><span class="p">,</span> <span class="nb">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">,</span> <span class="n">dest</span> <span class="o">=</span> <span class="s2">&quot;time_abs_tol&quot;</span><span class="p">,</span>
                     <span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Variable to determine how close a peak time should be to match the rest of a cluster of peaks.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s2">&quot;-uat&quot;</span><span class="p">,</span><span class="s2">&quot;--uv_abs_tol&quot;</span><span class="p">,</span><span class="n">action</span> <span class="o">=</span> <span class="s2">&quot;store&quot;</span><span class="p">,</span> <span class="nb">type</span> <span class="o">=</span> <span class="nb">int</span><span class="p">,</span> <span class="n">dest</span> <span class="o">=</span> <span class="s2">&quot;uv_abs_tol&quot;</span><span class="p">,</span>
                     <span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Variable to determine how close the UV max should be to be counted in the same cluster.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s2">&quot;-mpa&quot;</span><span class="p">,</span><span class="s2">&quot;--min_peak_area&quot;</span><span class="p">,</span><span class="n">action</span> <span class="o">=</span> <span class="s2">&quot;store&quot;</span><span class="p">,</span> <span class="nb">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">,</span> <span class="n">dest</span> <span class="o">=</span> <span class="s2">&quot;min_peak_area&quot;</span><span class="p">,</span>
                     <span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Variable to determine the minimum acceptable peak area given as a percentage of all peak areas.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s2">&quot;-mmt&quot;</span><span class="p">,</span><span class="s2">&quot;--min_massconf_threshold&quot;</span><span class="p">,</span> <span class="n">action</span> <span class="o">=</span> <span class="s2">&quot;store&quot;</span><span class="p">,</span><span class="nb">type</span> <span class="o">=</span> <span class="nb">int</span><span class="p">,</span><span class="n">dest</span> <span class="o">=</span> <span class="s2">&quot;min_massconf_threshold&quot;</span><span class="p">,</span>
                     <span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Variable to determine the lowest massConf at which a hit will be recorded.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s2">&quot;-mut&quot;</span><span class="p">,</span><span class="s2">&quot;--min_uv_threshold&quot;</span><span class="p">,</span> <span class="n">action</span> <span class="o">=</span> <span class="s2">&quot;store&quot;</span><span class="p">,</span> <span class="nb">type</span> <span class="o">=</span> <span class="nb">int</span><span class="p">,</span> <span class="n">dest</span> <span class="o">=</span> <span class="s2">&quot;min_uv_threshold&quot;</span><span class="p">,</span>
                     <span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Minimum threshold before a UV signal can actually be considered to be a maxima.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s2">&quot;-umt&quot;</span><span class="p">,</span><span class="s2">&quot;--uv_match_threshold&quot;</span><span class="p">,</span> <span class="n">action</span> <span class="o">=</span> <span class="s2">&quot;store&quot;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">dest</span> <span class="o">=</span> <span class="s2">&quot;uv_match_threshold&quot;</span><span class="p">,</span>
                     <span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Variable to determine what fraction of UV maxima a hit needs to have to be deemed not orange.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s2">&quot;-uct&quot;</span><span class="p">,</span><span class="s2">&quot;--uv_cluster_threshold&quot;</span><span class="p">,</span> <span class="n">action</span> <span class="o">=</span> <span class="s2">&quot;store&quot;</span><span class="p">,</span><span class="nb">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">,</span> <span class="n">dest</span> <span class="o">=</span> <span class="s2">&quot;uv_cluster_threshold&quot;</span><span class="p">,</span>
                     <span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Variable to determine how big a UV cluster must be compared to the largest UV cluster expressed as a fraction.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s2">&quot;-mt&quot;</span><span class="p">,</span><span class="s2">&quot;--massconf_threshold&quot;</span><span class="p">,</span> <span class="n">action</span> <span class="o">=</span> <span class="s2">&quot;store&quot;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">dest</span> <span class="o">=</span> <span class="s2">&quot;massconf_threshold&quot;</span><span class="p">,</span>
                     <span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Variable for threshold at which a massConf is deemed too far below the mean for that cluster to be worthy of inclusion in cluster[&#39;green&#39;].</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s2">&quot;-cst&quot;</span><span class="p">,</span><span class="s2">&quot;--cluster_size_threshold&quot;</span><span class="p">,</span> <span class="n">action</span> <span class="o">=</span> <span class="s2">&quot;store&quot;</span><span class="p">,</span> <span class="nb">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">,</span> <span class="n">dest</span> <span class="o">=</span> <span class="s2">&quot;cluster_size_threshold&quot;</span><span class="p">,</span>
                     <span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Variable, defining the point at which a cluster is deemed too small to be valid, by comparison to the length of the largest cluster, as a percentage.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s2">&quot;-r&quot;</span><span class="p">,</span><span class="s2">&quot;--rows&quot;</span><span class="p">,</span><span class="n">action</span> <span class="o">=</span> <span class="s2">&quot;store&quot;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">dest</span> <span class="o">=</span> <span class="s2">&quot;plate_row_no&quot;</span><span class="p">,</span>
                     <span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Number of rows in the plate.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s2">&quot;-c&quot;</span><span class="p">,</span><span class="s2">&quot;--columns&quot;</span><span class="p">,</span><span class="n">action</span> <span class="o">=</span> <span class="s2">&quot;store&quot;</span><span class="p">,</span> <span class="nb">type</span> <span class="o">=</span> <span class="nb">int</span><span class="p">,</span> <span class="n">dest</span> <span class="o">=</span> <span class="s2">&quot;plate_col_no&quot;</span><span class="p">,</span>
                     <span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Number of columns in the plate.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s2">&quot;-now&quot;</span><span class="p">,</span> <span class="s2">&quot;--min_no_of_wells&quot;</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s2">&quot;store&quot;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">dest</span> <span class="o">=</span> <span class="s2">&quot;min_no_of_wells&quot;</span><span class="p">,</span> 
                        <span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Minimum number of wells that have a hit before validation process is run.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s2">&quot;-ppt&quot;</span><span class="p">,</span> <span class="s2">&quot;--points_per_trace&quot;</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s2">&quot;store&quot;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">dest</span> <span class="o">=</span> <span class="s2">&quot;points_per_trace&quot;</span><span class="p">,</span> 
                        <span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Define data points per chromatogram as an integer.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s2">&quot;-moa&quot;</span><span class="p">,</span> <span class="s2">&quot;--mass_or_area&quot;</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s2">&quot;store&quot;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span> <span class="n">dest</span> <span class="o">=</span> <span class="s2">&quot;mass_or_area&quot;</span><span class="p">,</span> 
                        <span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;&#39;mass_conf&#39; or &#39;area&#39;: Choose how to determine which peak is chosen in the absence of validation.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s2">&quot;-pt&quot;</span><span class="p">,</span> <span class="s2">&quot;--plot_type&quot;</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s2">&quot;store&quot;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span> <span class="n">dest</span> <span class="o">=</span> <span class="s2">&quot;plot_type&quot;</span><span class="p">,</span>
                        <span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Choose what to plot in the heatmap and piechart &quot;</span>
                               <span class="s2">&quot;from the following options: SMarea, Parea, STDarea, &quot;</span>
                               <span class="s2">&quot;corrSMarea, corrParea, corrSTDarea, P/SM+P, P/STD, &quot;</span>
                               <span class="s2">&quot;corrP/STD, corrP/SM+P.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s2">&quot;-chi&quot;</span><span class="p">,</span> <span class="s2">&quot;--calc_higherions&quot;</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s2">&quot;store&quot;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span> <span class="n">dest</span> <span class="o">=</span> <span class="s2">&quot;calc_higherions&quot;</span><span class="p">,</span>
                        <span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Look for [M+2H]2+ and [M+3H]3+ to find hits and calculate the mass confidence&quot;</span>
                        <span class="s2">&quot; of a peak, True/False&quot;</span><span class="p">)</span>
                        
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s2">&quot;-cboc&quot;</span><span class="p">,</span> <span class="s2">&quot;--calc_boc&quot;</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s2">&quot;store&quot;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span> <span class="n">dest</span> <span class="o">=</span> <span class="s2">&quot;calc_boc&quot;</span><span class="p">,</span>
                        <span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Look for Boc degradation ions, True/False&quot;</span><span class="p">)</span>
                        
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s2">&quot;-g&quot;</span><span class="p">,</span> <span class="s2">&quot;--generate_csv&quot;</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s2">&quot;store&quot;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span> <span class="n">dest</span> <span class="o">=</span> <span class="s2">&quot;gen_csv&quot;</span><span class="p">,</span> 
                        <span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Choose to generate and save a CSV, True/False.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s2">&quot;-z&quot;</span><span class="p">,</span> <span class="s2">&quot;--generate_zip&quot;</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s2">&quot;store&quot;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span> <span class="n">dest</span> <span class="o">=</span> <span class="s2">&quot;gen_zip&quot;</span><span class="p">,</span> 
                        <span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Choose to generate and save a zip file, True/False.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s2">&quot;-f&quot;</span><span class="p">,</span> <span class="s2">&quot;--filter_by_rt&quot;</span><span class="p">,</span> <span class="n">nargs</span> <span class="o">=</span> <span class="s2">&quot;+&quot;</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s2">&quot;store&quot;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span> <span class="n">dest</span> <span class="o">=</span> <span class="s2">&quot;filter_by_rt&quot;</span><span class="p">,</span>
                        <span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Provide retention time ranges to ignore, in the form &#39;mintime-maxtime&#39;&quot;</span>
                        <span class="s2">&quot; where the two times are separated by a hyphen. Multiple ranges (separated by a space) are excepted. &quot;</span><span class="p">)</span>

    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s2">&quot;-n&quot;</span><span class="p">,</span> <span class="s2">&quot;--name&quot;</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s2">&quot;store&quot;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span> <span class="n">dest</span> <span class="o">=</span> <span class="s2">&quot;analysis_name&quot;</span><span class="p">,</span> 
                        <span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Choose a name for the analysis.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s2">&quot;-d&quot;</span><span class="p">,</span> <span class="s2">&quot;--detector&quot;</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s2">&quot;store&quot;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span> <span class="n">dest</span> <span class="o">=</span> <span class="s2">&quot;detector&quot;</span><span class="p">,</span>
                        <span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Choose which detector to use, UV or ELSD. Waters data only.&quot;</span><span class="p">)</span>
    
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s2">&quot;-ffi&quot;</span><span class="p">,</span> <span class="s2">&quot;--find_freq_imp&quot;</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s2">&quot;store&quot;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span> <span class="n">dest</span> <span class="o">=</span> <span class="s2">&quot;find_freq_imp&quot;</span><span class="p">,</span>
                        <span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Choose whether to search for and report frequently observed impurities. &quot;</span><span class="p">)</span>

    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s2">&quot;-i&quot;</span><span class="p">,</span> <span class="s2">&quot;--instrument&quot;</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s2">&quot;store&quot;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span> <span class="n">dest</span> <span class="o">=</span> <span class="s2">&quot;instrument&quot;</span><span class="p">,</span>
                        <span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Select the data originated from, Waters or Shimadzu&quot;</span><span class="p">)</span>

    <span class="c1">#Set options to global and parse arguments        </span>
    <span class="n">times</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">global</span> <span class="n">options</span>
    <span class="n">options</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">()</span>
    
    <span class="c1">#Set standard matplotlib graph size</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s2">&quot;figure.figsize&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>

    <span class="c1">#Ensure all required input options have a valid address</span>
    <span class="n">root_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">options</span><span class="o">.</span><span class="n">input_data</span><span class="p">,</span> <span class="n">options</span><span class="o">.</span><span class="n">input_csv</span><span class="p">,</span> <span class="n">options</span><span class="o">.</span><span class="n">output</span><span class="p">]</span>
    
    <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">root_names</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;/&quot;</span><span class="p">):</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;./&quot;</span><span class="p">):</span>
                <span class="n">name</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;./&quot;</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">())</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">name</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()</span> <span class="o">+</span> <span class="s2">&quot;/&quot;</span> <span class="o">+</span> <span class="n">name</span>    
    
    <span class="c1">#Create the save directory if one isn&#39;t already present.</span>
    <span class="n">save_dir</span> <span class="o">=</span> <span class="n">root_names</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">save_dir</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;/&quot;</span><span class="p">):</span>
        <span class="n">save_dir</span> <span class="o">=</span> <span class="n">save_dir</span> <span class="o">+</span> <span class="s2">&quot;/&quot;</span>
    
    <span class="n">error_msg</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">save_dir</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">OSError</span> <span class="k">as</span> <span class="n">error</span><span class="p">:</span>
        <span class="n">error_msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;The directory &quot;</span><span class="si">{</span><span class="n">save_dir</span><span class="si">}</span><span class="s1">&quot; already exists.&#39;</span>
	
    <span class="c1">#Start logging, and log error_msg if one was created whilst making the output</span>
    <span class="c1">#directory. </span>
    <span class="k">if</span> <span class="n">options</span><span class="o">.</span><span class="n">verbose</span> <span class="o">==</span> <span class="s2">&quot;True&quot;</span><span class="p">:</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">basicConfig</span><span class="p">(</span><span class="n">filename</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">save_dir</span><span class="si">}</span><span class="s1">/logfile.txt&#39;</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">logging</span><span class="o">.</span><span class="n">DEBUG</span><span class="p">)</span>    
    <span class="k">else</span><span class="p">:</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">basicConfig</span><span class="p">(</span><span class="n">filename</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">save_dir</span><span class="si">}</span><span class="s1">/logfile.txt&#39;</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">error_msg</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">error_msg</span><span class="p">)</span>
    
    <span class="c1">#Boiler plate logs </span>
    <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;PyParse was run from the following directory: </span><span class="si">{</span><span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()</span><span class="si">}</span><span class="s1">.&#39;</span><span class="p">)</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;The output files were saved to </span><span class="si">{</span><span class="n">save_dir</span><span class="si">}</span><span class="s1">.&#39;</span><span class="p">)</span>

    <span class="c1">#Generate a generic HTML output file so that PyParse displays</span>
    <span class="c1">#the log file even in cases of uncaught errors. </span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">save_dir</span><span class="si">}</span><span class="s1">html_output.html&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Unspecified error occurred. See logfile for details.&#39;</span><span class="p">)</span>
        <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="c1">#make sub-directories to store all graphs and pictures of structures</span>
    <span class="k">try</span><span class="p">:</span> 
        <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">save_dir</span><span class="si">}</span><span class="s1">/graphs&#39;</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">OSError</span> <span class="k">as</span> <span class="n">error</span><span class="p">:</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Graphs directory already exists.&quot;</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span> 
        <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">save_dir</span><span class="si">}</span><span class="s1">/structures&#39;</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">OSError</span> <span class="k">as</span> <span class="n">error</span><span class="p">:</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Structures directory already exists.&quot;</span><span class="p">)</span>

    
    <span class="c1">#Check to ensure the root names of the data file/folder and csv file are correct, i.e. they exist</span>
    <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="p">[</span><span class="n">root_names</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">root_names</span><span class="p">[</span><span class="mi">1</span><span class="p">]]:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">access</span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="n">os</span><span class="o">.</span><span class="n">R_OK</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Input file/folder </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1"> does not exist. Please use an appropriate input file/folder.&#39;</span><span class="p">)</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">save_dir</span><span class="si">}</span><span class="s1">html_output.html&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Input file/folder </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1"> does not exist. Please use an appropriate input file/folder.&#39;</span><span class="p">)</span>
                <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

    <span class="c1">#Check to make sure the platemap is in the .csv format. </span>
    <span class="k">if</span> <span class="n">root_names</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">4</span><span class="p">:]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">!=</span> <span class="s2">&quot;.csv&quot;</span><span class="p">:</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Plate map is not in the .csv format. Please use a .csv file format.&#39;</span><span class="p">)</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">save_dir</span><span class="si">}</span><span class="s1">html_output.html&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Plate map is not in the .csv format. Please use a .csv file format.&#39;</span><span class="p">)</span>
            <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">options</span><span class="o">.</span><span class="n">instrument</span> <span class="o">==</span> <span class="s2">&quot;Waters&quot;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">root_names</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="o">-</span><span class="mi">4</span><span class="p">:]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">!=</span> <span class="s2">&quot;.rpt&quot;</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;LCMS data is not in the .rpt format. Please use a .rpt file format.&#39;</span><span class="p">)</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">save_dir</span><span class="si">}</span><span class="s1">html_output.html&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;LCMS data is not in the .rpt format. Please use a .rpt file format.&#39;</span><span class="p">)</span>
                <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">options</span><span class="o">.</span><span class="n">instrument</span> <span class="o">==</span> <span class="s2">&quot;Shimadzu&quot;</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root_names</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;/&quot;</span><span class="p">):</span>
            <span class="n">root_names</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">root_names</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;/&quot;</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">root_names</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;*.daml&#39;</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;No .daml files found. Please specify alternative directory with .daml files present.&#39;</span><span class="p">)</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">save_dir</span><span class="si">}</span><span class="s1">html_output.html&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;No .daml files found. Please specify a directory with .daml files present.&#39;</span><span class="p">)</span>
                <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>


    <span class="n">times</span><span class="p">[</span><span class="s2">&quot;Initialise Script&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span> <span class="o">-</span> <span class="n">time_start</span> 

    <span class="c1">#Convert the LCMS data into the preferred format. The output is a dictionary,</span>
    <span class="c1">#indexed by the well on the plate, and each value is a list. </span>
    <span class="c1">#each value in the list is a dictionary corresponding to each </span>
    <span class="c1">#peak in the well. </span>
    <span class="c1">#chroma is a list of lists containing the information required to </span>
    <span class="c1">#generate the LCMS trace. </span>
    
    <span class="n">pre_rpt</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span>

    <span class="c1">#Depending on the instrument specified, fetch the LCMS data and convert it to the </span>
    <span class="c1">#correct format. </span>
    <span class="k">if</span> <span class="n">options</span><span class="o">.</span><span class="n">instrument</span> <span class="o">==</span> <span class="s2">&quot;Waters&quot;</span><span class="p">:</span>
        <span class="n">getWatersData</span><span class="o">.</span><span class="n">init</span><span class="p">(</span><span class="n">options</span><span class="p">)</span>
        <span class="p">[</span><span class="n">dataTable</span><span class="p">,</span> <span class="n">chroma</span><span class="p">,</span> <span class="n">sample_IDs</span><span class="p">,</span> <span class="n">total_area_abs</span><span class="p">]</span> <span class="o">=</span> <span class="n">getWatersData</span><span class="o">.</span><span class="n">getData</span><span class="p">(</span><span class="n">root_names</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">times</span><span class="p">[</span><span class="s2">&quot;Import RPT File&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span> <span class="o">-</span> <span class="n">pre_rpt</span> 
        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">dataTable</span><span class="o">.</span><span class="n">items</span><span class="p">())</span><span class="si">}</span><span class="s1"> wells were found in the rpt.&#39;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">options</span><span class="o">.</span><span class="n">instrument</span> <span class="o">==</span> <span class="s2">&quot;Shimadzu&quot;</span><span class="p">:</span>
        <span class="n">getShimadzuData</span><span class="o">.</span><span class="n">init</span><span class="p">(</span><span class="n">options</span><span class="p">)</span>
        <span class="p">[</span><span class="n">dataTable</span><span class="p">,</span> <span class="n">chroma</span><span class="p">,</span> <span class="n">sample_IDs</span><span class="p">,</span> <span class="n">total_area_abs</span><span class="p">]</span> <span class="o">=</span> <span class="n">getShimadzuData</span><span class="o">.</span><span class="n">getData</span><span class="p">(</span><span class="n">root_names</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">dataTable</span><span class="o">.</span><span class="n">items</span><span class="p">())</span><span class="si">}</span><span class="s1"> .daml data sources were found in the folder specified.&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;This instrument is not currently supported by PyParse&quot;</span><span class="p">)</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

    <span class="c1">#Add blank values to wells in total_area_abs for which no data was found. </span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">options</span><span class="o">.</span><span class="n">plate_row_no</span> <span class="o">*</span> <span class="n">options</span><span class="o">.</span><span class="n">plate_col_no</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">total_area_abs</span><span class="p">:</span>
            <span class="n">total_area_abs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    

    <span class="c1">#Import the structure data from the comma-separated values platemap file provided</span>
    <span class="c1">#by the user to initiate the compoundDF. </span>
    <span class="n">pre_import</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span>            
    <span class="p">[</span><span class="n">compoundDF</span><span class="p">,</span> <span class="n">internalSTD</span><span class="p">,</span> <span class="n">SMs</span><span class="p">,</span> <span class="n">products</span><span class="p">,</span> <span class="n">by_products</span><span class="p">]</span> <span class="o">=</span> <span class="n">importStructures</span><span class="p">(</span><span class="n">root_names</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">save_dir</span><span class="p">)</span>

    <span class="c1">#Check that an internal standard was provided if the plot_type expects one</span>
    <span class="k">if</span> <span class="n">options</span><span class="o">.</span><span class="n">plot_type</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;P/STD&quot;</span><span class="p">,</span> <span class="s2">&quot;corrP/STD&quot;</span><span class="p">]</span> <span class="ow">and</span> <span class="n">internalSTD</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;No internal standard was provided. Halting program.&quot;</span><span class="p">)</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">save_dir</span><span class="si">}</span><span class="s1">html_output.html&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;No internal standard was provided for an analysis type which required one.&quot;</span><span class="p">)</span>
            <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

    <span class="c1">#append all the compounds into a master list to make a </span>
    <span class="c1">#pandas categorical for sorting</span>

    <span class="n">all_compounds</span> <span class="o">=</span> <span class="p">[</span><span class="n">product</span> <span class="k">for</span> <span class="n">product</span> <span class="ow">in</span> <span class="n">products</span><span class="p">]</span>
    <span class="n">all_compounds</span> <span class="o">=</span> <span class="n">all_compounds</span> <span class="o">+</span> <span class="p">[</span><span class="n">byprod</span> <span class="k">for</span> <span class="n">byprod</span> <span class="ow">in</span> <span class="n">by_products</span><span class="p">]</span>
    <span class="n">all_compounds</span> <span class="o">=</span> <span class="n">all_compounds</span> <span class="o">+</span> <span class="p">[</span><span class="n">SM</span> <span class="k">for</span> <span class="n">SM</span> <span class="ow">in</span> <span class="n">SMs</span><span class="p">]</span>
    <span class="n">all_compounds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">internalSTD</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span> 
        <span class="n">compoundDF</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Categorical</span><span class="p">(</span><span class="n">compoundDF</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span> <span class="n">categories</span> <span class="o">=</span> <span class="n">all_compounds</span><span class="p">,</span> <span class="n">ordered</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">compoundDF</span><span class="o">.</span><span class="n">sort_values</span><span class="p">([</span><span class="s2">&quot;name&quot;</span><span class="p">],</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;The substrates could not be categorised. Check to ensure that duplicate compounds have not been assigned different labels &quot;</span>
                    <span class="s2">&quot;or that two by-products have not been given the same label.&quot;</span><span class="p">)</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">save_dir</span><span class="si">}</span><span class="s1">html_output.html&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;The substrates could not be categorised. Check to ensure that duplicate compounds have not been assigned different labels &quot;</span>
                    <span class="s2">&quot;or that two by-products have not been given the same label.&quot;</span><span class="p">)</span>
            <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

    <span class="c1">#Log the time taken to complete these actions</span>
    <span class="n">times</span><span class="p">[</span><span class="s2">&quot;Import Compound File&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span> <span class="o">-</span> <span class="n">pre_import</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">compoundDF</span><span class="o">.</span><span class="n">index</span><span class="p">)</span><span class="si">}</span><span class="s1"> compounds were imported.&#39;</span><span class="p">)</span>

    <span class="c1">#For each compound, find all hits using the dataTable, validate them, and append </span>
    <span class="c1">#them to a list ready for insertion into the compoundDF pandas dataframe</span>
    <span class="n">pre_hit_and_val</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span>
    <span class="n">validated_hits</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">comment_text</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">cluster_bands</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">compoundDF</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
        <span class="n">hits</span> <span class="o">=</span> <span class="n">findHits</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">dataTable</span><span class="p">)</span>
        
        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Hit finding was completed for </span><span class="si">{</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span><span class="si">}</span><span class="s1">.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">hits</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1">#Validate the hits (or just choose the best well based on</span>
            <span class="c1">#options.mass_or_area) using the name of the compound</span>
            <span class="c1">#the hits, and the expected retention time if one was provided</span>
            <span class="c1">#by the user. </span>
            <span class="n">validHits</span> <span class="o">=</span> <span class="n">validateHits</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span> <span class="n">hits</span><span class="p">,</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;rt&quot;</span><span class="p">])</span>
            
            <span class="c1">#Append the data to appropriate columns ready to add to the </span>
            <span class="c1">#pandas datatable for compounds. </span>
            <span class="n">validated_hits</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">validHits</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">comment_text</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">validHits</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">cluster_bands</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">validHits</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Validation was completed for </span><span class="si">{</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span><span class="si">}</span><span class="s1">.&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1">#if no hits were found, append the appropriate data</span>
            <span class="c1">#structure so that no error is incurred in the future. </span>
            <span class="n">placeholder</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="s2">&quot;green&quot;</span><span class="p">:</span> <span class="p">[],</span>
                    <span class="s2">&quot;discarded&quot;</span><span class="p">:</span> <span class="p">[],</span> 
                    <span class="s2">&quot;discarded_by_cluster&quot;</span><span class="p">:</span> <span class="p">[]</span>
                    <span class="p">}</span>
            <span class="n">validated_hits</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">placeholder</span><span class="p">)</span>

            <span class="n">cluster_bands</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
            <span class="n">new_comments</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s1">&#39;&lt;strong&gt;No hits were found for </span><span class="si">{</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span><span class="si">}</span><span class="s1">.&lt;/strong&gt;&#39;</span><span class="p">]</span>
            <span class="n">new_comments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;No validation was performed for </span><span class="si">{</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span><span class="si">}</span><span class="s1"> &#39;</span>
                                <span class="s1">&#39;as no hits were found.&#39;</span><span class="p">)</span>
            <span class="n">comment_text</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_comments</span><span class="p">)</span>

    

    <span class="c1">#append the hits for each compound as a new column to the dataframe</span>
    <span class="n">compoundDF</span><span class="p">[</span><span class="s2">&quot;hits&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">validated_hits</span>
    <span class="n">compoundDF</span><span class="p">[</span><span class="s2">&quot;comments&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">comment_text</span>
    <span class="n">compoundDF</span><span class="p">[</span><span class="s2">&quot;cluster_bands&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cluster_bands</span>  
    <span class="n">times</span><span class="p">[</span><span class="s2">&quot;Find Hits and Validate&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span> <span class="o">-</span> <span class="n">pre_hit_and_val</span>
    
    <span class="c1">#Check no peak has been assigned twice, and reassign if necessary</span>
    <span class="n">pre_rem_dup</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span>
    <span class="n">compoundDF</span> <span class="o">=</span> <span class="n">removeDupAssigns</span><span class="p">(</span><span class="n">compoundDF</span><span class="p">,</span> <span class="n">internalSTD</span><span class="p">,</span> <span class="n">SMs</span><span class="p">,</span> <span class="n">products</span><span class="p">,</span> <span class="n">by_products</span><span class="p">)</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Duplicate assignments were removed.&#39;</span><span class="p">)</span>
    <span class="n">times</span><span class="p">[</span><span class="s2">&quot;Remove Duplicate Assignments&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span> <span class="o">-</span> <span class="n">pre_rem_dup</span>

    
    
    <span class="c1">#Generate the output table using validated hits</span>
    <span class="n">pre_output_table</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span>
    <span class="n">outputTable</span> <span class="o">=</span> <span class="n">generateOutputTable</span><span class="p">(</span><span class="n">compoundDF</span><span class="p">,</span> <span class="n">internalSTD</span><span class="p">,</span> <span class="n">SMs</span><span class="p">,</span> <span class="n">products</span><span class="p">,</span> <span class="n">by_products</span><span class="p">,</span> <span class="n">total_area_abs</span><span class="p">)</span>

    <span class="c1">#Insert blanks in sample_IDs to match length of datatable</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">options</span><span class="o">.</span><span class="n">plate_row_no</span> <span class="o">*</span> <span class="n">options</span><span class="o">.</span><span class="n">plate_col_no</span> <span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">sample_IDs</span><span class="p">:</span>
            <span class="n">sample_IDs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;No Data.&quot;</span>
    
    <span class="n">sorted_IDs</span> <span class="o">=</span> <span class="p">[</span><span class="n">value</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">sample_IDs</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="n">key</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span>
    <span class="n">outputTable</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;SampleID&quot;</span><span class="p">,</span> <span class="n">sorted_IDs</span><span class="p">)</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;The output table was generated.&#39;</span><span class="p">)</span>
    <span class="n">times</span><span class="p">[</span><span class="s2">&quot;Generate Output Table&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span> <span class="o">-</span> <span class="n">pre_output_table</span>
    
    
    <span class="c1">#if the plot_type requires the internalSTD to be present, </span>
    <span class="c1">#check to ensure a non-zero area of internalSTD is present in all wells</span>
    <span class="n">warn_for_std</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">options</span><span class="o">.</span><span class="n">plot_type</span> <span class="o">==</span> <span class="s2">&quot;P/STD&quot;</span> <span class="ow">or</span> <span class="n">options</span><span class="o">.</span><span class="n">plot_type</span> <span class="o">==</span> <span class="s2">&quot;corrP/STD&quot;</span><span class="p">:</span>
        <span class="n">min_std</span> <span class="o">=</span> <span class="n">outputTable</span><span class="p">[</span><span class="s2">&quot;STDarea&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">min_std</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">warn_for_std</span> <span class="o">=</span> <span class="kc">True</span>
    
    <span class="c1">#Plot graphs of retentiontime vs well for all hits, for each compound</span>
    <span class="c1">#During the same loop, gather information to push into the compoundDF. </span>
    <span class="n">pre_plotting</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span>
    <span class="n">best_wells</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">best_masses_plus</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">best_masses_minus</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">best_peak_areas</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">best_times</span> <span class="o">=</span> <span class="p">[]</span> 
    <span class="n">overlaps</span> <span class="o">=</span> <span class="p">[]</span>   
    
    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">compoundDF</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
         
        <span class="c1">#Plot hit validation graph for the compound</span>
        <span class="n">plotHitValidationGraph</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;hits&quot;</span><span class="p">],</span> <span class="n">save_dir</span><span class="p">,</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;cluster_bands&quot;</span><span class="p">])</span>
        
        <span class="c1">#Append a warning to the internalSTD if necessary</span>
        <span class="k">if</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">internalSTD</span> <span class="ow">and</span> <span class="n">warn_for_std</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">compoundDF</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">index</span><span class="p">,</span> <span class="s2">&quot;comments&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;&lt;strong&gt;The internal standard was not found in all wells. &quot;</span>
                                    <span class="s2">&quot;Recommend re-running analysis using Parea or corrParea analysis type.&lt;/strong&gt;&quot;</span><span class="p">)</span>
                                    
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;hits&quot;</span><span class="p">][</span><span class="s2">&quot;green&quot;</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            
            <span class="c1">#find which well gives the best conditions:</span>
            <span class="c1">#For the product, this should reflect the metric the user selected.</span>
            <span class="c1">#e.g. Parea or corrP/STD </span>
            <span class="k">if</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span> <span class="ow">in</span> <span class="n">products</span><span class="p">:</span>
                <span class="n">new_slice</span> <span class="o">=</span> <span class="n">outputTable</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">outputTable</span><span class="p">[</span><span class="s2">&quot;well_no&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;locations&quot;</span><span class="p">])]</span>
                <span class="n">max_index</span> <span class="o">=</span> <span class="n">new_slice</span><span class="p">[</span><span class="n">options</span><span class="o">.</span><span class="n">plot_type</span><span class="p">]</span><span class="o">.</span><span class="n">idxmax</span><span class="p">()</span>
                <span class="n">best_well_id</span> <span class="o">=</span> <span class="n">new_slice</span><span class="p">[</span><span class="s2">&quot;well_no&quot;</span><span class="p">][</span><span class="n">max_index</span><span class="p">]</span>
                <span class="n">best_well_poss</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;hits&quot;</span><span class="p">][</span><span class="s2">&quot;green&quot;</span><span class="p">]</span> <span class="k">if</span> <span class="n">i</span><span class="p">[</span><span class="s2">&quot;well&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">best_well_id</span><span class="p">]</span>
                
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_well_poss</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">best_well</span> <span class="o">=</span> <span class="n">best_well_poss</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">best_well</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;hits&quot;</span><span class="p">][</span><span class="s2">&quot;green&quot;</span><span class="p">],</span> <span class="n">key</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="s2">&quot;area&quot;</span><span class="p">])</span>
                    
            <span class="k">else</span><span class="p">:</span>
                <span class="n">best_well</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;hits&quot;</span><span class="p">][</span><span class="s2">&quot;green&quot;</span><span class="p">],</span> <span class="n">key</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="s2">&quot;area&quot;</span><span class="p">])</span>
            
            <span class="n">annotate_peaks</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">bindex</span><span class="p">,</span> <span class="n">brow</span> <span class="ow">in</span> <span class="n">compoundDF</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
                <span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">brow</span><span class="p">[</span><span class="s2">&quot;hits&quot;</span><span class="p">][</span><span class="s2">&quot;green&quot;</span><span class="p">]</span> <span class="k">if</span> <span class="n">i</span><span class="p">[</span><span class="s2">&quot;well&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">best_well</span><span class="p">[</span><span class="s2">&quot;well&quot;</span><span class="p">]]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">annotate_peaks</span><span class="o">.</span><span class="n">append</span><span class="p">({</span>
                            <span class="s2">&quot;cpname&quot;</span><span class="p">:</span> <span class="n">brow</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span> 
                            <span class="s2">&quot;time&quot;</span><span class="p">:</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;time&quot;</span><span class="p">]</span>
                            <span class="p">})</span>
            
            <span class="c1">#Get the ms data for the relevant peak in the best_well</span>
            <span class="n">ms_plus</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="s2">&quot;MS+&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">dataTable</span><span class="p">[</span><span class="n">best_well</span><span class="p">[</span><span class="s2">&quot;well&quot;</span><span class="p">]]</span> 
                                <span class="k">if</span> <span class="n">i</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">best_well</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">]][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">ms_minus</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="s2">&quot;MS-&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">dataTable</span><span class="p">[</span><span class="n">best_well</span><span class="p">[</span><span class="s2">&quot;well&quot;</span><span class="p">]]</span> 
                                <span class="k">if</span> <span class="n">i</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">best_well</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">]][</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">try</span><span class="p">:</span>  
                <span class="n">plotChroma</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span> <span class="n">best_well</span><span class="p">[</span><span class="s2">&quot;well&quot;</span><span class="p">],</span> <span class="n">chroma</span><span class="p">[</span><span class="n">best_well</span><span class="p">[</span><span class="s2">&quot;well&quot;</span><span class="p">]],</span> 
                        <span class="n">best_well</span><span class="p">[</span><span class="s2">&quot;pStart&quot;</span><span class="p">],</span> <span class="n">best_well</span><span class="p">[</span><span class="s2">&quot;pEnd&quot;</span><span class="p">],</span> 
                        <span class="n">annotate_peaks</span><span class="p">,</span> <span class="n">save_dir</span><span class="p">,</span> <span class="n">ms_plus</span><span class="p">,</span> <span class="n">ms_minus</span><span class="p">,</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;mass1&quot;</span><span class="p">])</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;A chromatogram plotted for </span><span class="si">{</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span><span class="si">}</span><span class="s1"> for well &#39;</span>
                                <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">best_well</span><span class="p">[</span><span class="s2">&quot;well&quot;</span><span class="p">]</span><span class="si">}</span><span class="s1">.&#39;</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;No chromatogram could be plotted. Data not found.&quot;</span><span class="p">)</span>

            <span class="c1">#Convert the well no. into a user readable format, then append it </span>
            <span class="c1">#to an array for upload to the compoundDF. </span>
            <span class="n">best_wells</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">getUserReadableWell</span><span class="p">(</span><span class="n">best_well</span><span class="p">[</span><span class="s2">&quot;well&quot;</span><span class="p">]))</span>
            
            <span class="c1">#Prepare to add the best peak area, and a warning as to whether</span>
            <span class="c1">#the hit peak overlaps with another peak, to the compoundDF. </span>
            <span class="n">best_peak_areas</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">best_well</span><span class="p">[</span><span class="s2">&quot;area&quot;</span><span class="p">])</span>
            <span class="n">best_masses_plus</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">best_well</span><span class="p">[</span><span class="s2">&quot;mass+&quot;</span><span class="p">])</span>
            <span class="n">best_masses_minus</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">best_well</span><span class="p">[</span><span class="s2">&quot;mass-&quot;</span><span class="p">])</span>
            <span class="n">best_times</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">best_well</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">],</span> <span class="mi">2</span><span class="p">))</span>
            <span class="n">is_overlap</span> <span class="o">=</span> <span class="n">findOverlap</span><span class="p">(</span><span class="n">dataTable</span><span class="p">,</span> <span class="n">best_well</span><span class="p">[</span><span class="s2">&quot;well&quot;</span><span class="p">],</span>
                                                    <span class="n">best_well</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">])</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">is_overlap</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">overlaps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;&lt;strong&gt;Peak overlap detected!&lt;/strong&gt;&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">overlaps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;No peak overlap detected.&quot;</span><span class="p">)</span>

            
        <span class="k">else</span><span class="p">:</span>
            <span class="c1">#Append appropriate placeholders to the data structure so that</span>
            <span class="c1">#there are no null values in the compoundDF. </span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;hits&quot;</span><span class="p">][</span><span class="s2">&quot;discarded&quot;</span><span class="p">])</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>

                <span class="n">annotate_peaks</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">best_well</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;hits&quot;</span><span class="p">][</span><span class="s2">&quot;discarded&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">bindex</span><span class="p">,</span> <span class="n">brow</span> <span class="ow">in</span> <span class="n">compoundDF</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">brow</span><span class="p">[</span><span class="s2">&quot;hits&quot;</span><span class="p">][</span><span class="s2">&quot;green&quot;</span><span class="p">]</span> <span class="k">if</span> <span class="n">i</span><span class="p">[</span><span class="s2">&quot;well&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">best_well</span><span class="p">[</span><span class="s2">&quot;well&quot;</span><span class="p">]]</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">annotate_peaks</span><span class="o">.</span><span class="n">append</span><span class="p">({</span>
                                <span class="s2">&quot;cpname&quot;</span><span class="p">:</span> <span class="n">brow</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span> 
                                <span class="s2">&quot;time&quot;</span><span class="p">:</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;time&quot;</span><span class="p">]</span>
                                <span class="p">})</span>
                
                <span class="c1">#Get the ms data for the relevant peak in the best_well</span>
                <span class="n">ms_plus</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="s2">&quot;MS+&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">dataTable</span><span class="p">[</span><span class="n">best_well</span><span class="p">[</span><span class="s2">&quot;well&quot;</span><span class="p">]]</span> 
                                    <span class="k">if</span> <span class="n">i</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">best_well</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">]][</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">ms_minus</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="s2">&quot;MS-&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">dataTable</span><span class="p">[</span><span class="n">best_well</span><span class="p">[</span><span class="s2">&quot;well&quot;</span><span class="p">]]</span> 
                                    <span class="k">if</span> <span class="n">i</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">best_well</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">]][</span><span class="mi">0</span><span class="p">]</span>   
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">plotChroma</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span> <span class="n">best_well</span><span class="p">[</span><span class="s2">&quot;well&quot;</span><span class="p">],</span> <span class="n">chroma</span><span class="p">[</span><span class="n">best_well</span><span class="p">[</span><span class="s2">&quot;well&quot;</span><span class="p">]],</span> 
                            <span class="n">best_well</span><span class="p">[</span><span class="s2">&quot;pStart&quot;</span><span class="p">],</span> <span class="n">best_well</span><span class="p">[</span><span class="s2">&quot;pEnd&quot;</span><span class="p">],</span> 
                            <span class="n">annotate_peaks</span><span class="p">,</span> <span class="n">save_dir</span><span class="p">,</span> <span class="n">ms_plus</span><span class="p">,</span> <span class="n">ms_minus</span><span class="p">,</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;mass1&quot;</span><span class="p">])</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;No chromatogram could be plotted. Data not found.&quot;</span><span class="p">)</span>
            
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;locations&quot;</span><span class="p">])</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>

                <span class="n">annotate_peaks</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">only_well</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;locations&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">bindex</span><span class="p">,</span> <span class="n">brow</span> <span class="ow">in</span> <span class="n">compoundDF</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">brow</span><span class="p">[</span><span class="s2">&quot;hits&quot;</span><span class="p">][</span><span class="s2">&quot;green&quot;</span><span class="p">]</span> <span class="k">if</span> <span class="n">i</span><span class="p">[</span><span class="s2">&quot;well&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">only_well</span><span class="p">]</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">annotate_peaks</span><span class="o">.</span><span class="n">append</span><span class="p">({</span>
                                <span class="s2">&quot;cpname&quot;</span><span class="p">:</span> <span class="n">brow</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span> 
                                <span class="s2">&quot;time&quot;</span><span class="p">:</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;time&quot;</span><span class="p">]</span>
                                <span class="p">})</span>
                
                <span class="c1">#Get the ms data for the relevant peak in the best_well</span>
                <span class="n">ms_plus</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">ms_minus</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">try</span><span class="p">:</span>  
                    <span class="n">plotChroma</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span> <span class="n">only_well</span><span class="p">,</span> <span class="n">chroma</span><span class="p">[</span><span class="n">only_well</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> 
                            <span class="n">annotate_peaks</span><span class="p">,</span> <span class="n">save_dir</span><span class="p">,</span> <span class="n">ms_plus</span><span class="p">,</span> <span class="n">ms_minus</span><span class="p">,</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;mass1&quot;</span><span class="p">])</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;No chromatogram could be plotted. Data not found.&quot;</span><span class="p">)</span>



            <span class="n">overlaps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;N/A&quot;</span><span class="p">)</span>
            <span class="n">best_wells</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;None found.&quot;</span><span class="p">)</span>
            <span class="n">best_peak_areas</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">best_masses_plus</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;-&quot;</span><span class="p">)</span>
            <span class="n">best_masses_minus</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;-&quot;</span><span class="p">)</span>
            <span class="n">best_times</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            
    <span class="c1">#Merge the new data into the compoundDF. </span>
    <span class="n">compoundDF</span><span class="p">[</span><span class="s2">&quot;best_well&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">best_wells</span>
    <span class="n">compoundDF</span><span class="p">[</span><span class="s2">&quot;best_purity&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">best_peak_areas</span>
    <span class="n">compoundDF</span><span class="p">[</span><span class="s2">&quot;overlaps&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">overlaps</span>
    <span class="n">compoundDF</span><span class="p">[</span><span class="s2">&quot;mass+&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">best_masses_plus</span>
    <span class="n">compoundDF</span><span class="p">[</span><span class="s2">&quot;mass-&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">best_masses_minus</span>
    <span class="n">compoundDF</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">best_times</span>
    <span class="n">times</span><span class="p">[</span><span class="s2">&quot;Plot Peaks&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span> <span class="o">-</span> <span class="n">pre_plotting</span>
    
    <span class="c1">#check all compounds for similar retention times to another compound</span>
    <span class="c1">#which may also appear in one of the same wells, to flag to the user</span>
    <span class="c1">#that a compound may be hiding underneath the peak of another. This </span>
    <span class="c1">#additional check is useful in case the program didn&#39;t find both compounds</span>
    <span class="c1">#for a peak because the m/z for one compound was too small. </span>
    <span class="n">pre_checks</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span>
    <span class="n">pot_conflicts</span> <span class="o">=</span> <span class="n">findPotentialConflicts</span><span class="p">(</span><span class="n">compoundDF</span><span class="p">)</span>
    <span class="n">compoundDF</span><span class="p">[</span><span class="s2">&quot;conflicts&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pot_conflicts</span>
    <span class="n">times</span><span class="p">[</span><span class="s2">&quot;Find Potential Conlicts&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span> <span class="o">-</span> <span class="n">pre_checks</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Potential conflicts were searched for all compounds.&#39;</span><span class="p">)</span>

    <span class="c1">#Return a heatmap to the user</span>
    <span class="n">pre_heatmap</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span>
    <span class="n">plotHeatmaps</span><span class="p">(</span><span class="n">outputTable</span><span class="p">,</span> <span class="n">save_dir</span><span class="p">)</span>
    <span class="n">times</span><span class="p">[</span><span class="s2">&quot;Generate Heatmap&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span> <span class="o">-</span> <span class="n">pre_heatmap</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;A heatmap was generated using </span><span class="si">{</span><span class="n">options</span><span class="o">.</span><span class="n">plot_type</span><span class="si">}</span><span class="s1"> &#39;</span>
                <span class="sa">f</span><span class="s1">&#39;as the index.&#39;</span><span class="p">)</span>

    <span class="c1">#Return a series of piecharts to the user, as long as it&#39;s not larger than</span>
    <span class="c1">#a 96 well plate. For larger plates, the piecharts become too small to be</span>
    <span class="c1">#useful. </span>
    <span class="k">if</span> <span class="n">options</span><span class="o">.</span><span class="n">plate_row_no</span> <span class="o">*</span> <span class="n">options</span><span class="o">.</span><span class="n">plate_col_no</span> <span class="o">&lt;</span> <span class="mi">97</span><span class="p">:</span>
        <span class="n">pre_pie</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span>
        <span class="c1">#Alter the piechart output depending on whether an internalSTD was specified</span>
        <span class="c1">#in the platemap or not. </span>
        <span class="k">if</span> <span class="n">internalSTD</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
            <span class="n">plotPieCharts</span><span class="p">(</span><span class="s2">&quot;corrP/STD&quot;</span><span class="p">,</span> <span class="n">outputTable</span><span class="p">,</span> <span class="n">save_dir</span><span class="p">,</span> <span class="n">by_products</span><span class="p">)</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;A set of pie-charts was generated using corrP/STD &#39;</span>
                        <span class="sa">f</span><span class="s1">&#39;as the index.&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">plotPieCharts</span><span class="p">(</span><span class="s2">&quot;Parea&quot;</span><span class="p">,</span> <span class="n">outputTable</span><span class="p">,</span> <span class="n">save_dir</span><span class="p">,</span> <span class="n">by_products</span><span class="p">)</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;A set of pie-charts was generated using Parea &#39;</span>
                        <span class="sa">f</span><span class="s1">&#39;as the index.&#39;</span><span class="p">)</span>
        <span class="n">times</span><span class="p">[</span><span class="s2">&quot;Generate Piechart&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span> <span class="o">-</span> <span class="n">pre_pie</span>

    <span class="c1">#Plot a histogram and donut chart of Parea as a measure of plate success. </span>
    <span class="n">pre_donut</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span>
    <span class="n">plotHistogram</span><span class="p">(</span><span class="n">outputTable</span><span class="p">,</span> <span class="n">save_dir</span><span class="p">)</span>
    <span class="n">plotDonut</span><span class="p">(</span><span class="n">outputTable</span><span class="p">,</span> <span class="n">save_dir</span><span class="p">)</span>
    <span class="n">times</span><span class="p">[</span><span class="s2">&quot;Generate Histogram and Donut&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span> <span class="o">-</span> <span class="n">pre_donut</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;A histogram and donut chart were generated.&#39;</span><span class="p">)</span>

    <span class="c1">#Generate a set of PNG files to depict each compound</span>
    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">compoundDF</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
        <span class="n">generateMol</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;g_smiles&quot;</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span> <span class="n">save_dir</span><span class="p">)</span>

    <span class="c1">#Search for impurities that haven&#39;t been specified</span>
    <span class="k">if</span> <span class="n">options</span><span class="o">.</span><span class="n">find_freq_imp</span> <span class="o">==</span> <span class="s2">&quot;True&quot;</span><span class="p">:</span>
        <span class="n">impurities</span> <span class="o">=</span> <span class="n">findImpurities</span><span class="p">(</span><span class="n">dataTable</span><span class="p">,</span> <span class="n">compoundDF</span><span class="p">,</span> <span class="n">save_dir</span><span class="p">,</span> <span class="n">chroma</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">impurities</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1">#Generate location heatmaps based on the provided heatmap</span>
    <span class="n">genLocationHeatmaps</span><span class="p">(</span><span class="n">compoundDF</span><span class="p">,</span> <span class="n">save_dir</span><span class="p">)</span>

    <span class="c1">#Generate the HTML output. </span>
    <span class="n">times</span><span class="p">[</span><span class="s2">&quot;Total time&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span> <span class="o">-</span> <span class="n">pre_donut</span>
    <span class="n">buildHTML</span><span class="p">(</span><span class="n">save_dir</span><span class="p">,</span> <span class="n">compoundDF</span><span class="p">,</span> <span class="n">all_compounds</span><span class="p">,</span> <span class="n">impurities</span><span class="p">,</span> <span class="n">options</span><span class="o">.</span><span class="n">analysis_name</span><span class="p">,</span> <span class="n">times</span> <span class="o">=</span> <span class="n">times</span><span class="p">)</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;The HTML output was generated.&#39;</span><span class="p">)</span>
    
    
    
    <span class="c1">#Generate an csv of the output table.</span>
    <span class="k">if</span> <span class="n">options</span><span class="o">.</span><span class="n">gen_csv</span> <span class="o">==</span> <span class="s2">&quot;True&quot;</span><span class="p">:</span>
        <span class="n">csv</span> <span class="o">=</span> <span class="n">outputTable</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">save_dir</span><span class="si">}</span><span class="s1">outputTable.csv&#39;</span><span class="p">,</span> <span class="n">index</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>
        <span class="n">newslice</span> <span class="o">=</span> <span class="n">compoundDF</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="s2">&quot;g_smiles&quot;</span><span class="p">,</span> <span class="s2">&quot;mass1&quot;</span><span class="p">,</span> <span class="s2">&quot;mass2&quot;</span><span class="p">,</span> <span class="s2">&quot;mass3&quot;</span><span class="p">,</span>
                                <span class="s2">&quot;time&quot;</span><span class="p">,</span> <span class="s2">&quot;mass-&quot;</span><span class="p">,</span> <span class="s2">&quot;mass+&quot;</span><span class="p">,</span> <span class="s2">&quot;best_well&quot;</span><span class="p">,</span> <span class="s2">&quot;best_purity&quot;</span><span class="p">,</span> 
                                <span class="s2">&quot;overlaps&quot;</span><span class="p">,</span> <span class="s2">&quot;conflicts&quot;</span><span class="p">]]</span>

        <span class="n">csv2</span> <span class="o">=</span> <span class="n">newslice</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">save_dir</span><span class="si">}</span><span class="s1">compoundtable.csv&#39;</span><span class="p">,</span> <span class="n">index</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;The CSV outputs were generated.&#39;</span><span class="p">)</span>
    
    <span class="c1">#Generate a ZIP file containing all analysis files and graphs</span>

    <span class="k">if</span> <span class="n">options</span><span class="o">.</span><span class="n">gen_zip</span> <span class="o">==</span> <span class="s2">&quot;True&quot;</span><span class="p">:</span>

        <span class="k">with</span> <span class="n">zipfile</span><span class="o">.</span><span class="n">ZipFile</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">save_dir</span><span class="si">}</span><span class="s1">output.zip&#39;</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">,</span> <span class="n">allowZip64</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="k">as</span> <span class="n">myzip</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">path</span><span class="p">,</span> <span class="n">directories</span><span class="p">,</span> <span class="n">files</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">walk</span><span class="p">(</span><span class="n">save_dir</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">file</span> <span class="ow">in</span> <span class="n">files</span><span class="p">:</span>
                    <span class="k">if</span> <span class="s2">&quot;.zip&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">file</span><span class="p">:</span>
                        <span class="n">filename</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">file</span><span class="p">)</span>
                        <span class="n">dst</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;/&quot;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s1">/</span><span class="si">{</span><span class="n">file</span><span class="si">}</span><span class="s1">&#39;</span>
                        <span class="n">myzip</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">arcname</span> <span class="o">=</span> <span class="n">dst</span><span class="p">)</span>
    
    

    <span class="n">total_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span> <span class="o">-</span> <span class="n">time_start</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;The analysis was completed in </span><span class="si">{</span><span class="n">total_time</span><span class="si">}</span><span class="s1"> seconds.&#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;The analysis was completed in </span><span class="si">{</span><span class="nb">round</span><span class="p">(</span><span class="n">total_time</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span><span class="si">}</span><span class="s1"> seconds.&#39;</span><span class="p">)</span></div>

   

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Running analysis....&quot;</span><span class="p">)</span>
        <span class="n">main</span><span class="p">()</span>
    <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">exception</span><span class="p">(</span><span class="s2">&quot;A fatal exception occurred. Contact administrator.&quot;</span><span class="p">)</span>
</pre></div>
        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          
          
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 2023, GlaxoSmithKline Research &amp; Development Limited
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            
          </div>
          <div class="right-details">
            
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer no-toc">
      
      
      
    </aside>
  </div>
</div><script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/scripts/furo.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    </body>
</html>